{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Why Cely # Cely's goal is to add a secure login system into your app in under 30 seconds! Background # Most applications that work with Keychain Services , use it to store sensitive information such as user credentials and tokens. When working with Keychain, you typically would find yourself using a framework like KeychainAccess , Locksmith , or keychain-swift . Even tutorials from some of the most reputable online resources encourage the use of these frameworks. Even Apple provides a wrapper around keychain. This is no coincidence either, Keychain Service is apart of Apple's lower level Security Framework which is written in C. I too would encourage you to use a framework instead of interfacing with this API directly. There's no need to reinvent the wheel when working with this API. But if you must, I suggest you bookmark osstatus.com to help you decipher all the possible OSStatus error codes your app will encounter. But storing information securely is only one half of the solution , the other half is building a Login system . This Login system will be an entirely different part of your codebase that will be responsible for interacting with your application's UIWindow , handle abrupt login status change (redirect to login screen), update Keychain, etc. This is where Cely comes in, it solves both problems by combining these two entirely different bits of functionality into one seamless all-in-one solution. Cely \ud83d\udea4 Add login functionality in a fraction of the time \ud83d\udd0f Store user information securely with Keychain \ud83d\udcd6 100% open source under the MIT license \u2604\ufe0f Battle tested architecture \ud83d\udc76 Simple and intutive API design \u2696\ufe0f Easily Add/Remove from existing codebase \ud83e\udd17 Questions and support # Before submitting a new GitHub issue, please make sure to search for existing issues . If that doesn't help, please submit an issue on GitHub and provide information about your application setup. License # This project is licensed under the terms of the MIT license. See the LICENSE file.","title":"Home"},{"location":"#why-cely","text":"Cely's goal is to add a secure login system into your app in under 30 seconds!","title":"Why Cely"},{"location":"#background","text":"Most applications that work with Keychain Services , use it to store sensitive information such as user credentials and tokens. When working with Keychain, you typically would find yourself using a framework like KeychainAccess , Locksmith , or keychain-swift . Even tutorials from some of the most reputable online resources encourage the use of these frameworks. Even Apple provides a wrapper around keychain. This is no coincidence either, Keychain Service is apart of Apple's lower level Security Framework which is written in C. I too would encourage you to use a framework instead of interfacing with this API directly. There's no need to reinvent the wheel when working with this API. But if you must, I suggest you bookmark osstatus.com to help you decipher all the possible OSStatus error codes your app will encounter. But storing information securely is only one half of the solution , the other half is building a Login system . This Login system will be an entirely different part of your codebase that will be responsible for interacting with your application's UIWindow , handle abrupt login status change (redirect to login screen), update Keychain, etc. This is where Cely comes in, it solves both problems by combining these two entirely different bits of functionality into one seamless all-in-one solution. Cely \ud83d\udea4 Add login functionality in a fraction of the time \ud83d\udd0f Store user information securely with Keychain \ud83d\udcd6 100% open source under the MIT license \u2604\ufe0f Battle tested architecture \ud83d\udc76 Simple and intutive API design \u2696\ufe0f Easily Add/Remove from existing codebase \ud83e\udd17","title":"Background"},{"location":"#questions-and-support","text":"Before submitting a new GitHub issue, please make sure to search for existing issues . If that doesn't help, please submit an issue on GitHub and provide information about your application setup.","title":"Questions and support"},{"location":"#license","text":"This project is licensed under the terms of the MIT license. See the LICENSE file.","title":"License"},{"location":"api/cely-credentials/","text":"Cely Credentials # set(_:) -> Result # Securely store user credentials. Declaration public func set( username: String, password: String, server: String, accessibility: [AccessibilityOptions] ) -> Result<Void, Error> Example // Example let credentialResult = Cely.credentials.set( username: username, password: password, server: \"api.example.com\" accessibility: [.biometricsIfPossible] ) switch credentialResult { case let .success: print(\"success!\") case let .failure(error): print(\"failed to store credentials\") } Parameters Parameter Type Required? Description username String \u2705 username for user. password String \u2705 password for user. server String \u2705 API uri for account. accessibility [AccessibilityOptions] no Array of AccessibilityOptions for credentials to be saved with. get() -> Result # Retrieve the current user's credentials Declaration func get() -> Result<CelyCredentials, Error> Example let result = Cely.credentials.get() switch result { case let .success(credentials): print(credentials) case let .failure(error): print(\"failed to get credentials\") }","title":"Cely Credentials"},{"location":"api/cely-credentials/#cely-credentials","text":"","title":"Cely Credentials"},{"location":"api/cely-credentials/#set_-gt-result","text":"Securely store user credentials. Declaration public func set( username: String, password: String, server: String, accessibility: [AccessibilityOptions] ) -> Result<Void, Error> Example // Example let credentialResult = Cely.credentials.set( username: username, password: password, server: \"api.example.com\" accessibility: [.biometricsIfPossible] ) switch credentialResult { case let .success: print(\"success!\") case let .failure(error): print(\"failed to store credentials\") } Parameters Parameter Type Required? Description username String \u2705 username for user. password String \u2705 password for user. server String \u2705 API uri for account. accessibility [AccessibilityOptions] no Array of AccessibilityOptions for credentials to be saved with.","title":"set(_:) -&gt; Result"},{"location":"api/cely-credentials/#get-gt-result","text":"Retrieve the current user's credentials Declaration func get() -> Result<CelyCredentials, Error> Example let result = Cely.credentials.get() switch result { case let .success(credentials): print(credentials) case let .failure(error): print(\"failed to get credentials\") }","title":"get() -&gt; Result"},{"location":"api/cely/","text":"Cely # Cely was made to help handle user credentials and handling login with ease. Below you will find documentation for Cely's Framework. Please do not hesitate to open an issue if something is unclear or is missing. setup(_:) # Configuration method for Cely. Declaration static func setup( with window: UIWindow?, forModel model: CelyUser, requiredProperties: [CelyProperty], withOptions options: [CelyOptions : Any?]? ) -> Void Example Cely.setup(with: window, forModel: User(), requiredProperties:[.token], withOptions:[ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginCompletionBlock: { (username: String, password: String) in if username == \"username\" && password == \"password\" { // ... Cely.changeStatus(to: .loggedIn) } } ]) Parameters Parameter Type Required? Description window UIWindow \u2705 window of your application. forModel CelyUser \u2705 The model Cely will be using to store data. requiredProperties [CelyProperty] The properties that cely tests against to determine if a user is logged in. Default value : empty array. options [CelyOptions: Any] Dictionary of CelyOptions to pass in additional customizations to Cely. changeStatus(_:) # Transition application between a loggedIn/loggedOut states. Declaration static func changeStatus(to status: CelyStatus) Example changeStatus(to: .loggedOut) Parameters Parameter Type Required? Description status CelyStatus \u2705 .loggedIn or .loggedOut get(_:) -> Any? # Retrieve data from store. Declaration static func get(key: String, fromStorage store: CelyStorageProtocol) -> Any? Example let username = Cely.get(key: \"username\") Parameters Parameter Type Required? Description key String \u2705 The key to the value you want to retrieve. store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage save(_:) -> Result # Saves data in store. Declaration static func save( _ value: Any?, forKey key: String, toStorage store: CelyStorageProtocol, securely secure: Bool, persisted persist: Bool ) -> Result<Void, Error> Example Cely.save(\"test@email.com\", forKey: \"email\") Cely.save(\"testUsername\", forKey: \"username\", persisted: true) Cely.save(\"token123\", forKey: \"token\", securely: true) Parameters Parameter Type Required? Description value Any? \u2705 The value you want to save to storage. key String \u2705 The key to the value you want to save. store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage . secure Bool no If you want to store the value securely. persist Bool no Keep data after logout. currentLoginStatus() -> CelyStatus # Returns CelyStatus of the current user. Declaration static func currentLoginStatus( requiredProperties properties: [CelyProperty], fromStorage store: CelyStorageProtocol ) -> CelyStatus Example let status = Cely.currentLoginStatus() Parameters Parameter Type Required? Description properties CelyProperty no Array of required properties that need to be in store. store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage logout(_:) # Convenience method to logout user and remove all non-persisted data. Declaration static func logout(useStorage store: CelyStorageProtocol = store) -> Result<Void, Error> Example Cely.logout() Parameters Parameter Type Required? Description store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage isLoggedIn() -> Bool # Returns boolean whether or not the user is logged in Declaration static func isLoggedIn() -> Bool Example if Cely.isLoggedIn() { print(\"is logged in\") }","title":"Cely"},{"location":"api/cely/#cely","text":"Cely was made to help handle user credentials and handling login with ease. Below you will find documentation for Cely's Framework. Please do not hesitate to open an issue if something is unclear or is missing.","title":"Cely"},{"location":"api/cely/#setup_","text":"Configuration method for Cely. Declaration static func setup( with window: UIWindow?, forModel model: CelyUser, requiredProperties: [CelyProperty], withOptions options: [CelyOptions : Any?]? ) -> Void Example Cely.setup(with: window, forModel: User(), requiredProperties:[.token], withOptions:[ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginCompletionBlock: { (username: String, password: String) in if username == \"username\" && password == \"password\" { // ... Cely.changeStatus(to: .loggedIn) } } ]) Parameters Parameter Type Required? Description window UIWindow \u2705 window of your application. forModel CelyUser \u2705 The model Cely will be using to store data. requiredProperties [CelyProperty] The properties that cely tests against to determine if a user is logged in. Default value : empty array. options [CelyOptions: Any] Dictionary of CelyOptions to pass in additional customizations to Cely.","title":"setup(_:)"},{"location":"api/cely/#changestatus_","text":"Transition application between a loggedIn/loggedOut states. Declaration static func changeStatus(to status: CelyStatus) Example changeStatus(to: .loggedOut) Parameters Parameter Type Required? Description status CelyStatus \u2705 .loggedIn or .loggedOut","title":"changeStatus(_:)"},{"location":"api/cely/#get_-gt-any","text":"Retrieve data from store. Declaration static func get(key: String, fromStorage store: CelyStorageProtocol) -> Any? Example let username = Cely.get(key: \"username\") Parameters Parameter Type Required? Description key String \u2705 The key to the value you want to retrieve. store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage","title":"get(_:) -&gt; Any?"},{"location":"api/cely/#save_-gt-result","text":"Saves data in store. Declaration static func save( _ value: Any?, forKey key: String, toStorage store: CelyStorageProtocol, securely secure: Bool, persisted persist: Bool ) -> Result<Void, Error> Example Cely.save(\"test@email.com\", forKey: \"email\") Cely.save(\"testUsername\", forKey: \"username\", persisted: true) Cely.save(\"token123\", forKey: \"token\", securely: true) Parameters Parameter Type Required? Description value Any? \u2705 The value you want to save to storage. key String \u2705 The key to the value you want to save. store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage . secure Bool no If you want to store the value securely. persist Bool no Keep data after logout.","title":"save(_:) -&gt; Result"},{"location":"api/cely/#currentloginstatus-gt-celystatus","text":"Returns CelyStatus of the current user. Declaration static func currentLoginStatus( requiredProperties properties: [CelyProperty], fromStorage store: CelyStorageProtocol ) -> CelyStatus Example let status = Cely.currentLoginStatus() Parameters Parameter Type Required? Description properties CelyProperty no Array of required properties that need to be in store. store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage","title":"currentLoginStatus() -&gt; CelyStatus"},{"location":"api/cely/#logout_","text":"Convenience method to logout user and remove all non-persisted data. Declaration static func logout(useStorage store: CelyStorageProtocol = store) -> Result<Void, Error> Example Cely.logout() Parameters Parameter Type Required? Description store CelyStorageProtocol no Storage Cely will be using. Defaulted to CelyStorage","title":"logout(_:)"},{"location":"api/cely/#isloggedin-gt-bool","text":"Returns boolean whether or not the user is logged in Declaration static func isLoggedIn() -> Bool Example if Cely.isLoggedIn() { print(\"is logged in\") }","title":"isLoggedIn() -&gt; Bool"},{"location":"api/constants/","text":"CelyOptions # Parameter Type Description .homeViewController UIViewController App's Home ViewController . .loginViewController UIViewController App's Login ViewController . .celyAnimator CelyAnimator Custom animation when login/logout occurs. .loginStyle CelyStyle Customize Cely's default LoginViewController . .loginCompletionBlock (username: String, password: String) -> Void Handle Login click on Cely's default LoginViewController . .storage CelyStorageProtocol Override Cely's storage with custom class. AccessibilityOptions # Parameter Description .biometricsIfPossible Store/retrieve credentials with biometrics (FaceID/TouchID). .thisDeviceOnly Only allow for credentials to be stored on current device. CelyStatus # enum Statuses for Cely to perform actions on Parameter Description .loggedIn Indicates user is now logged in. .loggedOut Indicates user is now logged out. CelyStorageError # CelyStorageError is an enum built to handle the possible errors that may come from working with Keychain Services. CelyStorageError was modeled after KeychainAccess's Status enum . Typealiases # CelyProperty # String typealias. Is used in User model CelyCommands # String typealias. Command for Cely to execute","title":"Constants"},{"location":"api/constants/#celyoptions","text":"Parameter Type Description .homeViewController UIViewController App's Home ViewController . .loginViewController UIViewController App's Login ViewController . .celyAnimator CelyAnimator Custom animation when login/logout occurs. .loginStyle CelyStyle Customize Cely's default LoginViewController . .loginCompletionBlock (username: String, password: String) -> Void Handle Login click on Cely's default LoginViewController . .storage CelyStorageProtocol Override Cely's storage with custom class.","title":"CelyOptions"},{"location":"api/constants/#accessibilityoptions","text":"Parameter Description .biometricsIfPossible Store/retrieve credentials with biometrics (FaceID/TouchID). .thisDeviceOnly Only allow for credentials to be stored on current device.","title":"AccessibilityOptions"},{"location":"api/constants/#celystatus","text":"enum Statuses for Cely to perform actions on Parameter Description .loggedIn Indicates user is now logged in. .loggedOut Indicates user is now logged out.","title":"CelyStatus"},{"location":"api/constants/#celystorageerror","text":"CelyStorageError is an enum built to handle the possible errors that may come from working with Keychain Services. CelyStorageError was modeled after KeychainAccess's Status enum .","title":"CelyStorageError"},{"location":"api/constants/#typealiases","text":"","title":"Typealiases"},{"location":"api/constants/#celyproperty","text":"String typealias. Is used in User model","title":"CelyProperty"},{"location":"api/constants/#celycommands","text":"String typealias. Command for Cely to execute","title":"CelyCommands"},{"location":"api/protocols/","text":"CelyUser # Protocol for an object to implement to allow Cely have access to the properties associated to a user. protocol CelyUser { /// Enum of all the properties you would like to save for a model associatedtype Property : RawRepresentable } // Usage import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } CelyStorageProtocol # In the case you need more control of how user information is stored, you can set the .storage CelyOption in Cely.setup(...) to an object that conforms to CelyStorageProtocol . /// Protocol a storage class must abide by in order for Cely to use it public protocol CelyStorageProtocol { func set(_ value: Any?, forKey key: String, securely secure: Bool, persisted persist: Bool) -> Result<Void, CelyStorageError> func get(_ key: String) -> Any? func removeAllData() } CelyStyle # A protocol for an object to conform to in order to customize Cely's default login screen. Since all methods are optional, Cely will use the default value for any unimplemented methods. /// Protocol that allows styles to be applied to Cely's default LoginViewController public protocol CelyStyle { func backgroundColor() -> UIColor func textFieldBackgroundColor() -> UIColor func buttonBackgroundColor() -> UIColor func buttonTextColor() -> UIColor func appLogo() -> UIImage? } CelyAnimator # A protocol for an object to conform to in order to customize transitions between home and login screens. /// Handles Animations between Home and Login ViewControllers public protocol CelyAnimator { func loginTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) func logoutTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) }","title":"Protocols"},{"location":"api/protocols/#celyuser","text":"Protocol for an object to implement to allow Cely have access to the properties associated to a user. protocol CelyUser { /// Enum of all the properties you would like to save for a model associatedtype Property : RawRepresentable } // Usage import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } }","title":"CelyUser"},{"location":"api/protocols/#celystorageprotocol","text":"In the case you need more control of how user information is stored, you can set the .storage CelyOption in Cely.setup(...) to an object that conforms to CelyStorageProtocol . /// Protocol a storage class must abide by in order for Cely to use it public protocol CelyStorageProtocol { func set(_ value: Any?, forKey key: String, securely secure: Bool, persisted persist: Bool) -> Result<Void, CelyStorageError> func get(_ key: String) -> Any? func removeAllData() }","title":"CelyStorageProtocol"},{"location":"api/protocols/#celystyle","text":"A protocol for an object to conform to in order to customize Cely's default login screen. Since all methods are optional, Cely will use the default value for any unimplemented methods. /// Protocol that allows styles to be applied to Cely's default LoginViewController public protocol CelyStyle { func backgroundColor() -> UIColor func textFieldBackgroundColor() -> UIColor func buttonBackgroundColor() -> UIColor func buttonTextColor() -> UIColor func appLogo() -> UIImage? }","title":"CelyStyle"},{"location":"api/protocols/#celyanimator","text":"A protocol for an object to conform to in order to customize transitions between home and login screens. /// Handles Animations between Home and Login ViewControllers public protocol CelyAnimator { func loginTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) func logoutTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) }","title":"CelyAnimator"},{"location":"guides/hybrid_re-authentication_flow/","text":"Introduction # The Hybrid Re-Authentication Flow is an alternative flow you can use instead of Loud Re-Authentication. It acts as a \"best of both worlds\" solution. It keeps application data protected while keeping user interuption at a minimum. This is made possible by using biometric technologies such as FaceID or TouchID. You typically see such a flow with banking apps, enterprise apps, or any other apps that deal with sensitive information. Hybrid Re-Authentication Flow Getting started # Before adding biometrics, its best to first understand what the difference is between Loud Re-Authentication and Quiet Re-Authentication . This guide will read as if your application already follows the Loud Re-Authentication flow. In the case that your application doesn't follow this flow one-for-one, feel free to make adjustments along the way. It is worth noting that Cely's default loginViewController does not support biometric login and requires for the developer to implement their own. First, we need permission from the user's iPhone to use biometrics. Add the NSFaceIDUsageDescription key in your application's Info.plist . Next, we need to save the user credentials with biometrics by using the .biometricsIfPossible flag: let credentialResult = Cely.credentials.set( username: username, password: password, server: \"api.example.com\" accessibility: [.biometricsIfPossible] ) if case let .failure(error) = credentialResult { return print(\"Cely store credentials error: \\(error)\") } Now anytime the application tries retrieve the credentials using Cely.credentials.get() , the user will be prompted to authenticate using biometrics. Cely has no opinion on whether the retrieval of credentials should happen at the Login layer (display app's loginViewController ) or the App/Scene Delegate layer (doesn't display loginViewController ). Protect application functionality #","title":"Hybrid re authentication flow"},{"location":"guides/hybrid_re-authentication_flow/#introduction","text":"The Hybrid Re-Authentication Flow is an alternative flow you can use instead of Loud Re-Authentication. It acts as a \"best of both worlds\" solution. It keeps application data protected while keeping user interuption at a minimum. This is made possible by using biometric technologies such as FaceID or TouchID. You typically see such a flow with banking apps, enterprise apps, or any other apps that deal with sensitive information. Hybrid Re-Authentication Flow","title":"Introduction"},{"location":"guides/hybrid_re-authentication_flow/#getting-started","text":"Before adding biometrics, its best to first understand what the difference is between Loud Re-Authentication and Quiet Re-Authentication . This guide will read as if your application already follows the Loud Re-Authentication flow. In the case that your application doesn't follow this flow one-for-one, feel free to make adjustments along the way. It is worth noting that Cely's default loginViewController does not support biometric login and requires for the developer to implement their own. First, we need permission from the user's iPhone to use biometrics. Add the NSFaceIDUsageDescription key in your application's Info.plist . Next, we need to save the user credentials with biometrics by using the .biometricsIfPossible flag: let credentialResult = Cely.credentials.set( username: username, password: password, server: \"api.example.com\" accessibility: [.biometricsIfPossible] ) if case let .failure(error) = credentialResult { return print(\"Cely store credentials error: \\(error)\") } Now anytime the application tries retrieve the credentials using Cely.credentials.get() , the user will be prompted to authenticate using biometrics. Cely has no opinion on whether the retrieval of credentials should happen at the Login layer (display app's loginViewController ) or the App/Scene Delegate layer (doesn't display loginViewController ).","title":"Getting started"},{"location":"guides/hybrid_re-authentication_flow/#protect-application-functionality","text":"","title":"Protect application functionality"},{"location":"guides/introduction/","text":"Overview # The purpose of these guides are to not only give more in-depth usage of Cely's API, but to also educate readers on what should be considered best practices when creating your application's authentication flow. Though these guides will be using Cely, the concepts/practices mentioned can be applied without Cely. First, you have to decide what type of Re-Authentication Flow makes the most sense for your application. The two types of Re-Authentication flows are: Quiet Re-Authentication Loud Re-Authentication These flows are not mutually exclusive. A Hybrid approach can be taken using functionality such as FaceID or TouchID. Quiet Re-Authentication Flow # Most iOS apps use this flow Not to be confused with Silent Authentication from the OAuth2 spec. Quiet Re-Authentication allows for an app to re-authenticate without requiring user interaction by using Keychain Services. This is done by storing the user's credentials (username & password) in Keychain and later retrieving them when the app needs to re-authenticate. You typically see this in application where the user is expecting immediate use from the application, such as social media apps, entertainment apps, and shopping apps. As far as the user is concerned, they only had to login once. This flow protects your application in the case where the user's password is updated on the web and you need to prompt the user to re-authenticate via a Login Screen. There are a few other cases where prompting the user to re-authenticate might be necessary in this flow, such as restoring the application from backup onto another device or the user disabling FaceID/TouchID on device. Both of which will be covered in Add Control List to Cely Credentials . Loud Re-Authentication Flow # Loud Re-Authentication requires the user to re-authenticate everytime the application is being launched from a Suspended or Terminated State. Loud Re-Authenticating apps do not retain authenticating information , such as token , past the allocated memory for the application. Meaning, once your application is in the Suspended or Terminated State , the application will require the user to reauthenticate to continue use the app. In the case that your application has stayed in the Background State long enough for the token to become expired, the above flow allows you to gracefully transition the application to the Login Screen. Preventing the user from interacting with the View that was initially displayed. You'll see this flow mostly with apps that contain very sensitive information such as banking apps or internal enterprise apps. Hybrid Re-Authentication Flow # The Hybrid Re-Authentication Flow is an alternative flow you can use instead of Loud Re-Authentication. It acts as a \"best of both worlds\" solution. It keeps application data protected while keeping user interuption at a minimum. This is made possible by using technologies such as FaceID or TouchID.","title":"Introduction"},{"location":"guides/introduction/#overview","text":"The purpose of these guides are to not only give more in-depth usage of Cely's API, but to also educate readers on what should be considered best practices when creating your application's authentication flow. Though these guides will be using Cely, the concepts/practices mentioned can be applied without Cely. First, you have to decide what type of Re-Authentication Flow makes the most sense for your application. The two types of Re-Authentication flows are: Quiet Re-Authentication Loud Re-Authentication These flows are not mutually exclusive. A Hybrid approach can be taken using functionality such as FaceID or TouchID.","title":"Overview"},{"location":"guides/introduction/#quiet-re-authentication-flow","text":"Most iOS apps use this flow Not to be confused with Silent Authentication from the OAuth2 spec. Quiet Re-Authentication allows for an app to re-authenticate without requiring user interaction by using Keychain Services. This is done by storing the user's credentials (username & password) in Keychain and later retrieving them when the app needs to re-authenticate. You typically see this in application where the user is expecting immediate use from the application, such as social media apps, entertainment apps, and shopping apps. As far as the user is concerned, they only had to login once. This flow protects your application in the case where the user's password is updated on the web and you need to prompt the user to re-authenticate via a Login Screen. There are a few other cases where prompting the user to re-authenticate might be necessary in this flow, such as restoring the application from backup onto another device or the user disabling FaceID/TouchID on device. Both of which will be covered in Add Control List to Cely Credentials .","title":"Quiet Re-Authentication Flow"},{"location":"guides/introduction/#loud-re-authentication-flow","text":"Loud Re-Authentication requires the user to re-authenticate everytime the application is being launched from a Suspended or Terminated State. Loud Re-Authenticating apps do not retain authenticating information , such as token , past the allocated memory for the application. Meaning, once your application is in the Suspended or Terminated State , the application will require the user to reauthenticate to continue use the app. In the case that your application has stayed in the Background State long enough for the token to become expired, the above flow allows you to gracefully transition the application to the Login Screen. Preventing the user from interacting with the View that was initially displayed. You'll see this flow mostly with apps that contain very sensitive information such as banking apps or internal enterprise apps.","title":"Loud Re-Authentication Flow"},{"location":"guides/introduction/#hybrid-re-authentication-flow","text":"The Hybrid Re-Authentication Flow is an alternative flow you can use instead of Loud Re-Authentication. It acts as a \"best of both worlds\" solution. It keeps application data protected while keeping user interuption at a minimum. This is made possible by using technologies such as FaceID or TouchID.","title":"Hybrid Re-Authentication Flow"},{"location":"guides/loud_re-authentication_flow/","text":"Introduction # Loud Re-Authentication requires the user to re-authenticate everytime the application enters the foreground from a suspended or terminated state. In addition, it will require re-authentication once the user is no longer authenticated with the API. Loud Re-Authentication with Cely # In the next few sections were going to be going over Cely's role/responsibility in this flow and how to adopt it with your application. App Launch Flow # With the recent changes made to the App's Life Cycle , depending on what version of iOS your application will support, iOS 12 and earlier or iOS 13 and later \u2014 you will need to call Cely.setup(_:) in different parts of your app's codebase. The rest of the guide will follow as if your application supports iOS 13 & later. In the next section we will shift our focus to scene(_:willConnectTo:options:) Cely Responsibility # // iOS 13 | Swift 5.0 | Xcode 11.0 import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [], withOptions: [ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginViewController: UIHostingController(rootView: LoginContentView()) ]) } } } Cely is configured to follow Loud Authentication by default if no requiredProperties are passed into Cely.setup(_:) . This protects the application from an unintended state. Next, we pass your application's UIWindow to give Cely the ability to switch inbetween your Login and Home Screen. Finally, we pass an instance of our User model which contains the Property enum. Since no requiredProperties are passed in, Cely will redirect the user to the Login screen. Developer Responsibility # Below is an example of what is required of the developer to implement in order to complete the App Launch Flow for Loud Re-Authentication . We check to see if the user is logged in \u2014 then retrieve the token . If no token is returned then we log the user out. Next, we check to see if the user's token is expired. If the token is expired we log the user out. class SceneDelegate: UIResponder, UIWindowSceneDelegate { ... func sceneWillEnterForeground(_ scene: UIScene) { if Cely.isLoggedIn() { guard let token = Cely.get(key: \"token\") as? String else { return Cely.logout() } LoginService.status(for: token) { result in switch result { case .success: case .failure(let error as HTTPError) where error == .unauthorized: Cely.logout() } } } } } class LoginService { static func status(for token: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { // make API call to check token status completionHandler(someResult) } } Login Flow # Though a built-in LoginViewController is provided by Cely, as of Cely v3, it is encouraged for this built-in controller to only be used for rapid development/prototyping and not production. In this example, once the API has authenticated our credentials we save the token in keychain using Cely.save(_:) . Lastly, we change the user's logged in status with cely using Cely.changeStatus(_:) which will transition our application to the .homeViewController . Below is a pseudo code example: let username = usernameTextField.text let password = passwordTextField.text Login.Service(username: username, password: password) class LoginService { static func login(username: String, password: String) { API.login(username: username, password: password) { result in switch result { case .success(let token): if Cely.save(token, forKey: \"token\", securely: true) == .success { Cely.changeStatus(to: .loggedIn) } case .failure(let error): // handle error } } } } Conclusion # In conclusion, with this guide you should be given a high level overview of how to implement Loud Re-Authentication in your application using Cely. This document is a living document so if something is not clear or if you feel we are missing something, please open up an issue on this repo. The Cely team values documentation above all, so your help to improve it would greatly be appreciated \ud83d\ude00.","title":"Loud re authentication flow"},{"location":"guides/loud_re-authentication_flow/#introduction","text":"Loud Re-Authentication requires the user to re-authenticate everytime the application enters the foreground from a suspended or terminated state. In addition, it will require re-authentication once the user is no longer authenticated with the API.","title":"Introduction"},{"location":"guides/loud_re-authentication_flow/#loud-re-authentication-with-cely","text":"In the next few sections were going to be going over Cely's role/responsibility in this flow and how to adopt it with your application.","title":"Loud Re-Authentication with Cely"},{"location":"guides/loud_re-authentication_flow/#app-launch-flow","text":"With the recent changes made to the App's Life Cycle , depending on what version of iOS your application will support, iOS 12 and earlier or iOS 13 and later \u2014 you will need to call Cely.setup(_:) in different parts of your app's codebase. The rest of the guide will follow as if your application supports iOS 13 & later. In the next section we will shift our focus to scene(_:willConnectTo:options:)","title":"App Launch Flow"},{"location":"guides/loud_re-authentication_flow/#cely-responsibility","text":"// iOS 13 | Swift 5.0 | Xcode 11.0 import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [], withOptions: [ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginViewController: UIHostingController(rootView: LoginContentView()) ]) } } } Cely is configured to follow Loud Authentication by default if no requiredProperties are passed into Cely.setup(_:) . This protects the application from an unintended state. Next, we pass your application's UIWindow to give Cely the ability to switch inbetween your Login and Home Screen. Finally, we pass an instance of our User model which contains the Property enum. Since no requiredProperties are passed in, Cely will redirect the user to the Login screen.","title":"Cely Responsibility"},{"location":"guides/loud_re-authentication_flow/#developer-responsibility","text":"Below is an example of what is required of the developer to implement in order to complete the App Launch Flow for Loud Re-Authentication . We check to see if the user is logged in \u2014 then retrieve the token . If no token is returned then we log the user out. Next, we check to see if the user's token is expired. If the token is expired we log the user out. class SceneDelegate: UIResponder, UIWindowSceneDelegate { ... func sceneWillEnterForeground(_ scene: UIScene) { if Cely.isLoggedIn() { guard let token = Cely.get(key: \"token\") as? String else { return Cely.logout() } LoginService.status(for: token) { result in switch result { case .success: case .failure(let error as HTTPError) where error == .unauthorized: Cely.logout() } } } } } class LoginService { static func status(for token: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { // make API call to check token status completionHandler(someResult) } }","title":"Developer Responsibility"},{"location":"guides/loud_re-authentication_flow/#login-flow","text":"Though a built-in LoginViewController is provided by Cely, as of Cely v3, it is encouraged for this built-in controller to only be used for rapid development/prototyping and not production. In this example, once the API has authenticated our credentials we save the token in keychain using Cely.save(_:) . Lastly, we change the user's logged in status with cely using Cely.changeStatus(_:) which will transition our application to the .homeViewController . Below is a pseudo code example: let username = usernameTextField.text let password = passwordTextField.text Login.Service(username: username, password: password) class LoginService { static func login(username: String, password: String) { API.login(username: username, password: password) { result in switch result { case .success(let token): if Cely.save(token, forKey: \"token\", securely: true) == .success { Cely.changeStatus(to: .loggedIn) } case .failure(let error): // handle error } } } }","title":"Login Flow"},{"location":"guides/loud_re-authentication_flow/#conclusion","text":"In conclusion, with this guide you should be given a high level overview of how to implement Loud Re-Authentication in your application using Cely. This document is a living document so if something is not clear or if you feel we are missing something, please open up an issue on this repo. The Cely team values documentation above all, so your help to improve it would greatly be appreciated \ud83d\ude00.","title":"Conclusion"},{"location":"guides/quiet_re-authentication_flow/","text":"Introduction # Quiet Re-Authentication allows your application to reauthenticate in the background without requiring the user to login. Below is a diagram illistrating the steps your application should take when adopting this flow. Quiet Re-Authentication Flow Quiet Re-Authentication with Cely # In the next few sections were going to be going over Cely's role/responsibility in this flow and how to adopt it into your application. App Launch Flow # Cely Responsibility # With the recent changes made to the App's Life Cycle , depending on what version of iOS your application will support, iOS 12 and earlier or iOS 13 and later \u2014 you will need to call Cely.setup(_:) in different parts of your app's codebase. The rest of the guide will follow as if your application supports iOS 13 & later. In the next section we will shift our focus to scene(_:willConnectTo:options:) // iOS 13 | Swift 5.0 | Xcode 11.0 import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginViewController: UIHostingController(rootView: LoginContentView()) ]) } } } As a brief explanation, we pass your application's UIWindow to give Cely access to switch inbetween your Login and Home Screen. Next, we pass an instance of our User model which contains the Property enum. Finally, using the requiredProperties parameter, we tell Cely what properties are required in order to continue to the .homeViewController . In this example, if Cely does not find a property .token in its storage, or if requiredProperties is empty, Cely will redirect the user to .loginViewController . Developer Responsibility # Below is an example of what is required of the developer to implement in order to complete the App Launch Flow for Quiet Re-Authentication . We check to see if the user is logged in \u2014 then retrieve the token . If no token is returned then we log the user out. Next, we check to see if the user's token is expired. If the token is expired we logout the user. We will finish writing sceneWillEnterForeground(_:) in the Expired Token Flow . class SceneDelegate: UIResponder, UIWindowSceneDelegate { ... func sceneWillEnterForeground(_ scene: UIScene) { if Cely.isLoggedIn() { guard let token = Cely.get(key: \"token\") as? String else { return Cely.logout() } LoginService.status(for: token) { result in switch result { case .success: case .failure(let error as HTTPError) where error == .unauthorized: // TODO: Revisit in Expired Token Flow } } } } } class LoginService { static func status(for token: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { // make API call to check token status completionHandler(someResult) } } Login Flow # Though a built-in LoginViewController is provided by Cely, as of Cely v3, it is encouraged for this built-in controller to only be used for rapid development/prototyping and not production. In this example, once the API has authenticated our credentials we save the token in keychain using Cely.save(_:) . If successful, we also store the user credentials in keychain using Cely.credentials.set(_:) . Lastly, we change the user's logged in status with cely using Cely.changeStatus(_:) which will transition our application to the .homeViewController . Below is a pseudo code example: // LoginViewController.swift let username = usernameTextField.text let password = passwordTextField.text Login.Service(username: username, password: password) class LoginService { ... static func login(username: String, password: String) { API.login(username: username, password: password) { result in switch result { case .success(let token): if Cely.save(token, forKey: \"token\", securely: true) == .success { Cely.credentials.set( username: username, password: password, server: \"api.example.com\" ) Cely.changeStatus(to: .loggedIn) } case .failure(let error): // handle error } } } } Expired Token Flow # If you come from a Backend development background, the idea of implementing a refresh token to handle re-authentication may seem like the best option, but its going to cost a bit of overhead and precious developer time. Instead, because of the security Keychain Services provides, we are able to store users credentials directly onto the device , making re-authentication extremely easy. How does Cely help us do this? Up until this point we have stored the API token in Keychain Services using Cely.save(_:) , but it is expected for this token to eventually expire. When it does expire, we will be receiving 401 errors from our API. Since we are following the Quiet Re-Authentication Flow , our application will re-authenticate the user instead of logging them out. There are two places where we need to handle Re-authentication. When the app launch, (if the user is already logged in) When an API request returns 401 error App Launch # With Scene based life-cycle events sceneWillEnterForeground(_:) will get called every time your application enters the foreground, regardless if its from a terminated/suspended state or background state. Below is a pseudo code example for when the application starts up: class SceneDelegate: UIResponder, UIWindowSceneDelegate { ... func sceneWillEnterForeground(_ scene: UIScene) { guard Cely.isLoggedIn() else { return } guard let token = Cely.get(key: \"token\") as? String else { return Cely.logout() } LoginService.status(for: token) { result in switch result { case .success: case .failure(let error as HTTPError) where error == .unauthorized: // * HERE * let credentials = Cely.credentials.get() LoginService.reAuthenticate(username: credentials.username, password: credentials.password) { // ... } } } } } class LoginService { ... static func reAuthenticate(username: String, password: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { API.login(username: username, password: password) { (result) in switch result { case .success(let token): if Cely.save(token, forKey: \"token\", securely: true) == .success { return completionHandler(.success(nil)) } case .failure(let error): // handle error // Log user out } } } } Handle 401 errors from API # It is up to the developer's discretion on how the second example, API request returns 401 error , will be architected. But essentially, you will need to do the following: Intercept a failed response from an API request Re-Authenticate user on success: re-request failed API request and continue original call sequence on failure: log user out class SomeService { static func getSomeData(with id: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { API.someEndpoint(id: id) { (result) in switch result { case .success(let data): // do something with data case .failure(let error as HTTPError) where error == .unauthorized: let credentials = Cely.credentials.get() return LoginService.reAuthenticate(username: credentials.username, password: credentials.password) { (result) in switch result { case .success(let token): // * UPDATE TOKEN * if Cely.save(token, forKey: \"token\", securely: true) == .success { return SomeService.getSomeData(with: id, completionHandler: completionHandler) } case .failure(let err as HTTPError) where err == .unauthorized: // handle error // Log user out } } } } } } Upon success, since the credentials used to re-authenticate are still valid, only update the token to avoid multiple expensive calls. Conclusion # In conclusion, with this guide you should be given a high level overview of how to implement Quiet Re-Authentication in your application using Cely. This document is a living document so if something is not clear or if you feel we are missing something, please open up an issue on this repo. The Cely team values documentation above all, so your help to improve it would greatly be appreciated \ud83d\ude00.","title":"Quiet re authentication flow"},{"location":"guides/quiet_re-authentication_flow/#introduction","text":"Quiet Re-Authentication allows your application to reauthenticate in the background without requiring the user to login. Below is a diagram illistrating the steps your application should take when adopting this flow. Quiet Re-Authentication Flow","title":"Introduction"},{"location":"guides/quiet_re-authentication_flow/#quiet-re-authentication-with-cely","text":"In the next few sections were going to be going over Cely's role/responsibility in this flow and how to adopt it into your application.","title":"Quiet Re-Authentication with Cely"},{"location":"guides/quiet_re-authentication_flow/#app-launch-flow","text":"","title":"App Launch Flow"},{"location":"guides/quiet_re-authentication_flow/#cely-responsibility","text":"With the recent changes made to the App's Life Cycle , depending on what version of iOS your application will support, iOS 12 and earlier or iOS 13 and later \u2014 you will need to call Cely.setup(_:) in different parts of your app's codebase. The rest of the guide will follow as if your application supports iOS 13 & later. In the next section we will shift our focus to scene(_:willConnectTo:options:) // iOS 13 | Swift 5.0 | Xcode 11.0 import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginViewController: UIHostingController(rootView: LoginContentView()) ]) } } } As a brief explanation, we pass your application's UIWindow to give Cely access to switch inbetween your Login and Home Screen. Next, we pass an instance of our User model which contains the Property enum. Finally, using the requiredProperties parameter, we tell Cely what properties are required in order to continue to the .homeViewController . In this example, if Cely does not find a property .token in its storage, or if requiredProperties is empty, Cely will redirect the user to .loginViewController .","title":"Cely Responsibility"},{"location":"guides/quiet_re-authentication_flow/#developer-responsibility","text":"Below is an example of what is required of the developer to implement in order to complete the App Launch Flow for Quiet Re-Authentication . We check to see if the user is logged in \u2014 then retrieve the token . If no token is returned then we log the user out. Next, we check to see if the user's token is expired. If the token is expired we logout the user. We will finish writing sceneWillEnterForeground(_:) in the Expired Token Flow . class SceneDelegate: UIResponder, UIWindowSceneDelegate { ... func sceneWillEnterForeground(_ scene: UIScene) { if Cely.isLoggedIn() { guard let token = Cely.get(key: \"token\") as? String else { return Cely.logout() } LoginService.status(for: token) { result in switch result { case .success: case .failure(let error as HTTPError) where error == .unauthorized: // TODO: Revisit in Expired Token Flow } } } } } class LoginService { static func status(for token: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { // make API call to check token status completionHandler(someResult) } }","title":"Developer Responsibility"},{"location":"guides/quiet_re-authentication_flow/#login-flow","text":"Though a built-in LoginViewController is provided by Cely, as of Cely v3, it is encouraged for this built-in controller to only be used for rapid development/prototyping and not production. In this example, once the API has authenticated our credentials we save the token in keychain using Cely.save(_:) . If successful, we also store the user credentials in keychain using Cely.credentials.set(_:) . Lastly, we change the user's logged in status with cely using Cely.changeStatus(_:) which will transition our application to the .homeViewController . Below is a pseudo code example: // LoginViewController.swift let username = usernameTextField.text let password = passwordTextField.text Login.Service(username: username, password: password) class LoginService { ... static func login(username: String, password: String) { API.login(username: username, password: password) { result in switch result { case .success(let token): if Cely.save(token, forKey: \"token\", securely: true) == .success { Cely.credentials.set( username: username, password: password, server: \"api.example.com\" ) Cely.changeStatus(to: .loggedIn) } case .failure(let error): // handle error } } } }","title":"Login Flow"},{"location":"guides/quiet_re-authentication_flow/#expired-token-flow","text":"If you come from a Backend development background, the idea of implementing a refresh token to handle re-authentication may seem like the best option, but its going to cost a bit of overhead and precious developer time. Instead, because of the security Keychain Services provides, we are able to store users credentials directly onto the device , making re-authentication extremely easy. How does Cely help us do this? Up until this point we have stored the API token in Keychain Services using Cely.save(_:) , but it is expected for this token to eventually expire. When it does expire, we will be receiving 401 errors from our API. Since we are following the Quiet Re-Authentication Flow , our application will re-authenticate the user instead of logging them out. There are two places where we need to handle Re-authentication. When the app launch, (if the user is already logged in) When an API request returns 401 error","title":"Expired Token Flow"},{"location":"guides/quiet_re-authentication_flow/#app-launch","text":"With Scene based life-cycle events sceneWillEnterForeground(_:) will get called every time your application enters the foreground, regardless if its from a terminated/suspended state or background state. Below is a pseudo code example for when the application starts up: class SceneDelegate: UIResponder, UIWindowSceneDelegate { ... func sceneWillEnterForeground(_ scene: UIScene) { guard Cely.isLoggedIn() else { return } guard let token = Cely.get(key: \"token\") as? String else { return Cely.logout() } LoginService.status(for: token) { result in switch result { case .success: case .failure(let error as HTTPError) where error == .unauthorized: // * HERE * let credentials = Cely.credentials.get() LoginService.reAuthenticate(username: credentials.username, password: credentials.password) { // ... } } } } } class LoginService { ... static func reAuthenticate(username: String, password: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { API.login(username: username, password: password) { (result) in switch result { case .success(let token): if Cely.save(token, forKey: \"token\", securely: true) == .success { return completionHandler(.success(nil)) } case .failure(let error): // handle error // Log user out } } } }","title":"App Launch"},{"location":"guides/quiet_re-authentication_flow/#handle-401-errors-from-api","text":"It is up to the developer's discretion on how the second example, API request returns 401 error , will be architected. But essentially, you will need to do the following: Intercept a failed response from an API request Re-Authenticate user on success: re-request failed API request and continue original call sequence on failure: log user out class SomeService { static func getSomeData(with id: String, completionHandler: @escaping (Result<Void?, Error>) -> Void) { API.someEndpoint(id: id) { (result) in switch result { case .success(let data): // do something with data case .failure(let error as HTTPError) where error == .unauthorized: let credentials = Cely.credentials.get() return LoginService.reAuthenticate(username: credentials.username, password: credentials.password) { (result) in switch result { case .success(let token): // * UPDATE TOKEN * if Cely.save(token, forKey: \"token\", securely: true) == .success { return SomeService.getSomeData(with: id, completionHandler: completionHandler) } case .failure(let err as HTTPError) where err == .unauthorized: // handle error // Log user out } } } } } } Upon success, since the credentials used to re-authenticate are still valid, only update the token to avoid multiple expensive calls.","title":"Handle 401 errors from API"},{"location":"guides/quiet_re-authentication_flow/#conclusion","text":"In conclusion, with this guide you should be given a high level overview of how to implement Quiet Re-Authentication in your application using Cely. This document is a living document so if something is not clear or if you feel we are missing something, please open up an issue on this repo. The Cely team values documentation above all, so your help to improve it would greatly be appreciated \ud83d\ude00.","title":"Conclusion"},{"location":"guides/understanding_keychain/","text":"Understanding Keychain # This is a living document, so expect updates in the future. \ud83d\udcd6 Introduction # Most applications that work with Keychain Services , use it to store sensitive information such as user credentials and tokens. When working with Keychain, you typically would find yourself using a framework like KeychainAccess , Locksmith , or keychain-swift . Even tutorials from some of the most reputable online resources encourage the use of these frameworks. Even Apple provides a wrapper around keychain. Now why is this article even necessary when the user can just use the Cely framework? We feel Cely should be considered as an end solution for 99% of codebases that store credentials securely and have a login system. It's the remaining 1% of codebases that require a small tweak that this article is targeting. We've seen many frameworks change their API only to accommodate a small fraction of their userbase. Given the remaining 1%, each requiring different solutions, trying to solve everyone's problem is not the approach the Cely team wants to take moving forward. Instead, we'd like to enable developers to build out this remaining 1% themselves. By the end of this article \u2014 we hope the reader should have a firm grasp of Keychain Services and what all that entails. We will cover Keychain Services in depth, going over simple CRUD operations, ACL, biometrics, etc. Keychain Anatomy # Note Keychain Services expects Core Foundation objects, hence the CF prefix on some of the properties/attributes, such as CFDictionary , CFData , etc. Don't be intimidated, you can still use the Data type since Apple has bridges for these types. Read Tool-Free Bridging for more information. The Keychain is an encrypted database stored on disk consistenting of Keychain Items . A Keychain Item is made up of attributes and the data you wish to encrypt. kSecClass # The kSecClass attribute describes to Keychain what classification an item is, and determines what other attributes can be stored with your item. For example, if your application was storing a certificate, you would use the kSecClassCertificate class attribute. This attribute tells Keychain what other attributes can be set on your item, such as kSecAttrIssuer and kSecAttrPublicKeyHash . Trying to set an attribute that doesn't exist on the kSecClass attribute will result in OSStatus code errSecNoSuchAttr: -25303 . Also, not setting the kSecClass key in your Keychain Item will result in OSStatus error errSecParam: -50 . Below are the available options for the kSecClass key: kSecClassGenericPassword kSecClassInternetPassword kSecClassCertificate kSecClassKey kSecClassIdentity If you want to see all available attributes regardless of class, here is the list . Keychain Operations # In the following sections we will explain how to perform CRUD operations to Keychain items and what are some common gotchas. Create Item # Use the SecItemAdd(_:) function to add an item to Keychain. Below is an example on how to add an item to Keychain. @IBAction func AddButtonClicked(_ sender: Any) { let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } print(\"successfully saved\") } This is a goldilock example, meaning everything is setup correctly and no error's occurred, this of course will not happen everytime. In the case AddButtonClicked(_:) executes twice, you'd expect that Keychain will add another item into its database with duplicate data, right? Wrong! This will result in error errSecDuplicateItem: -25299 . Please read errSecDuplicateItem documentation to get a set of attributes (primary keys) that must be unique. In the following example, we are trying to store two kSecClassInternetPassword items in the Keychain. Since the set of kSecAttrAccount and kSecAttrServer are not unique between the items, the item2 will result in the errSecDuplicateItem error. let item1: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData ] let status = SecItemAdd(item1 as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } // ---- let item2: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData, kSecAttrLabel: \"some new label attribute\" ] let status2 = SecItemAdd(item2 as CFDictionary, nil) guard status2 == errSecSuccess else { print(\"status:\", status2) // status: -25299 return } Querying Item(s) # Note from Apple documentation : By default, your app can freely retrieve its own keychain items but not those of other apps. However, keychain services does provide mechanisms for broadening or narrowing that accessibility, for example, using the kSecAttrAccessGroup attribute. Use the SecItemCopyMatching(_:) function to query item(s) from Keychain. With the example below, take note that we are only searching across kSecAttrServer and not including kSecAttrAccount . @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem else { print(\"no Item\") // errSecItemNotFound: -25300 return } print(\"result: \\(item)\") } In the case where multiple accounts have the same kSecAttrServer set, we'd expect to see an array of items returned. But with the above example, only one item was returned. This is because by default SecItemCopyMatching(_:) only returns the first match found . If you would like to return all items that match the provided query, you must set kSecMatchLimit in the query. let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, // <-- // ... ] The two most important attributes when retrieving an item are: kSecReturnAttributes : must be set to true in order to retrieve item's attributes kSecReturnData : must be set to true in order to retrieve secret data. Even setting kSecReturnData: true and excluding kSecReturnAttributes , or setting it to false, will result in item returning as nil . let query: [CFString: Any] = [ //... kSecReturnAttributes: false, kSecReturnData: true ] // ... // prints: no Item Updating Item # Use the SecItemUpdate(_:) function to update an item in Keychain. It is important to note that you should provide as many attributes to help Keychain filter what item to update. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be updated. @IBAction func updateClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\" ] let newAttributes: [CFString: Any] = [ kSecValueData: \"new-password\".data(using: String.Encoding.utf8)! ] let status = SecItemUpdate(query as CFDictionary, newAttributes as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully updated\") } Deleting Item # Use the SecItemDelete(_:) function to delete an item in Keychain. Just like when updating an item , you should provide as many attributes to help Keychain filter what item to delete. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be deleted. @IBAction func deleteClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\" ] let status = SecItemDelete(query as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully deleted\") } Accessibility # In this section we will go over how to configure when your application has access to your Keychain items . For this, we set the kSecAttrAccessible attribute. By default, this attribute it set to kSecAttrAccessibleWhenUnlocked , but values for this attribute fall within two categories: Items that can be restored from a backup of another device. kSecAttrAccessibleWhenUnlocked kSecAttrAccessibleAfterFirstUnlock Items that cannot be restored from a backup of another device. kSecAttrAccessibleWhenUnlockedThisDeviceOnly kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly If you are using kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly \u2013 be prepared to encounter the errSecNotAvailable: -25291 error if the user does not have a passcode set. Here is where you can prompt the user that: \"They must set a device passcode in order to continue.\" Example let query: [CFString: Any] = [ kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked, // ... ] Notes # You must also provide the item's encrypted data, kSecValueData , anytime you wish to update the kSecAttrAccessible attribute in the future. Add FaceID/TouchID # Access Control # In order to add biometrics such as FaceID or TouchID to a Keychain item, you must create a SecAccessControl object using the SecAccessControlCreateWithFlags(_:) function and set it the kSecAttrAccessControl attribute. example var error: Unmanaged<CFError>? = nil let accessControlObject = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: accessControlObject // ... ] // ... Flags # In this section we will be going over some of the flags you can set and what errors you may encounter. In you want to see the entire list of flags, please checkout SecAccessControlCreateFlag for more information. Flags we will go over: .userPresence - FaceID/TouchID/Device Passcode. .devicePasscode - Device Passcode only. .biometryAny - FaceID/TouchID only (allows for biometrics changes). .biometryCurrentSet - FaceID/TouchID only (invalidates item when biometrics change). .applicationPassword - Application Specific password. NSFaceIDUsageDescription # When using .userPresence , if NSFaceIDUsageDescription is not set in your plist, your application will revert to prompting the user for the Device Passcode. But when using .biometryAny or .biometryCurrentSet , failing to set NSFaceIDUsageDescription will result in your application crashing with the following error: ERROR: This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an NSFaceIDUsageDescription key with a string value explaining to the user how the app uses this data. .userPresence # .userPresence is more than likely the flag you would be using in your application. Other flags such as .devicePasscode and .biometryAny , are simply slight derivatives of this flag. Above is the flow you can expect for your application to take when saving/retrieving a Keychain Item with the .userPresence flag. It is very possible to encounter errSecAuthFailed: -25293 errors when working with .userPresence flagged items. Please review the above flows for a better understanding. In addition to the Retrieving Flow , If the user adds back a passcode to the device (it doesn't have to be the same passcode) the item can once again be retrieved. .biometryCurrentSet # The flag that differs from .userPresence the most would be .biometryCurrentSet , it invalidates any Keychain Items once a finger is added/removed on TouchID or if the user re-enrolls for FaceID. .applicationPassword # The last flag we will go over is .applicationPassword , this allows for the user to set an application specific passcode in order to retrieve the item. When using this flag, iOS will prompt the user to insert a passcode. Meaning, you don't need to worry about providing a view to capture the application password. Unlike retrieving an item using device security such as .devicePasscode , after 5 failed attempts, Keychain returns the error errSecAuthFailed: -25293 instead of disabling the item retrieval. Meaning, after 5 failed attempts the user can simply try again without being penalized. Combining Flags # In the case you want to authenticate the user with both .userPresence and .applicationPassword , you may combine them using an array. var error: Unmanaged<CFError>? = nil let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, [.userPresence, .applicationPassword], &error) Some combinations are not allowed such as [.userPresence, .devicePasscode] , so be sure to print out any errors for more information. FaceID/TouchID Example # In this example, we will create an item that will require FaceID, TouchID, or Passcode in order to be retrieved. @IBAction func saveWithAccessFlagClicked(_ sender: Any) { var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) else { return } let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: access, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully saved with access attribute\") } Next, we will retrieve the .userPresence flagged item. @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem, let username = item[kSecAttrAccount] as? String, let passwordData = item[kSecValueData] as? Data, let password = String(data: passwordData, encoding: .utf8) else { print(\"Item not found\") return } print(\"username:\", username) print(\"password:\", password) } kSecUseAuthenticationUISkip # When querying items from Keychain, you may be returned items that have the kSecAttrAccessControl attribute set, which will require the user to authenticate in order to retrieve the item. You can exclude these results by setting the kSecUseAuthenticationUI attribute in your query. @IBAction func QueryAllClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, kSecUseAuthenticationUI: kSecUseAuthenticationUISkip, ... ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) ... Notes # When setting a kSecAttrAccessControl attribute on your Keychain Item, you cannot set the kSecAttrAccessible attribute on the Keychain Item itself. Doing so will result in a errSecParam: -50 error, even if both are set to the same value. As an example, the following will return an error: var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, // <-- .userPresence, &error) else { return } let query: [CFString: Any] = [ kSecAttrAccessControl: access, kSecAttrAccessible:kSecAttrAccessibleWhenUnlocked, // <-- //... ] let status = SecItemAdd(query as CFDictionary, nil) // equals -50 (errSecParam) Common Errors # errSecItemNotFound: -25300 # errSecItemNotFound , occurs when performing an Keychain operation such as SecItemCopyMatching(_:) , SecItemUpdate(_:) , or SecItemDelete(_:) and Keychain fails to find any matching items. In the case of SecItemUpdate(_:) and SecItemDelete(_:) , its best to query for the item before trying to perform an operation. errSecParam: -50 # errSecParam , occurs when you fail to properly set an attribute. Where I see this happening the most is when you fail to properly encode the kSecValueData as CFData or you fail to provide a necessary attribute such as kSecClass . I would investigate those two attributes first when you encounter errSecParam . errSecAuthFailed: -25293 # errSecAuthFailed , occurs when your application is trying to save an item that requires access control, but FaceID, TouchID, or Device Passcode are not setup on the device. Or if the user has removed the device's security since saving the item. errSecNoSuchAttr: -25303 # errSecNoSuchAttr , occurs when you try to set an attribute that doesn't exist for the provided kSecClass . In the bottom example we try to set kSecAttrIssuer , which is only available for the kSecClassCertificate class. let password = \"some-password\".data(using: String.Encoding.utf8)! let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrIssuer: \"Fabian issuer\".data(using: String.Encoding.utf8)!, // kSecClassCertificate only kSecAttrServer: \"example.com\", kSecValueData: password ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: -25303 return }","title":"Understanding Keychain"},{"location":"guides/understanding_keychain/#understanding-keychain","text":"This is a living document, so expect updates in the future. \ud83d\udcd6","title":"Understanding Keychain"},{"location":"guides/understanding_keychain/#introduction","text":"Most applications that work with Keychain Services , use it to store sensitive information such as user credentials and tokens. When working with Keychain, you typically would find yourself using a framework like KeychainAccess , Locksmith , or keychain-swift . Even tutorials from some of the most reputable online resources encourage the use of these frameworks. Even Apple provides a wrapper around keychain. Now why is this article even necessary when the user can just use the Cely framework? We feel Cely should be considered as an end solution for 99% of codebases that store credentials securely and have a login system. It's the remaining 1% of codebases that require a small tweak that this article is targeting. We've seen many frameworks change their API only to accommodate a small fraction of their userbase. Given the remaining 1%, each requiring different solutions, trying to solve everyone's problem is not the approach the Cely team wants to take moving forward. Instead, we'd like to enable developers to build out this remaining 1% themselves. By the end of this article \u2014 we hope the reader should have a firm grasp of Keychain Services and what all that entails. We will cover Keychain Services in depth, going over simple CRUD operations, ACL, biometrics, etc.","title":"Introduction"},{"location":"guides/understanding_keychain/#keychain-anatomy","text":"Note Keychain Services expects Core Foundation objects, hence the CF prefix on some of the properties/attributes, such as CFDictionary , CFData , etc. Don't be intimidated, you can still use the Data type since Apple has bridges for these types. Read Tool-Free Bridging for more information. The Keychain is an encrypted database stored on disk consistenting of Keychain Items . A Keychain Item is made up of attributes and the data you wish to encrypt.","title":"Keychain Anatomy"},{"location":"guides/understanding_keychain/#ksecclass","text":"The kSecClass attribute describes to Keychain what classification an item is, and determines what other attributes can be stored with your item. For example, if your application was storing a certificate, you would use the kSecClassCertificate class attribute. This attribute tells Keychain what other attributes can be set on your item, such as kSecAttrIssuer and kSecAttrPublicKeyHash . Trying to set an attribute that doesn't exist on the kSecClass attribute will result in OSStatus code errSecNoSuchAttr: -25303 . Also, not setting the kSecClass key in your Keychain Item will result in OSStatus error errSecParam: -50 . Below are the available options for the kSecClass key: kSecClassGenericPassword kSecClassInternetPassword kSecClassCertificate kSecClassKey kSecClassIdentity If you want to see all available attributes regardless of class, here is the list .","title":"kSecClass"},{"location":"guides/understanding_keychain/#keychain-operations","text":"In the following sections we will explain how to perform CRUD operations to Keychain items and what are some common gotchas.","title":"Keychain Operations"},{"location":"guides/understanding_keychain/#create-item","text":"Use the SecItemAdd(_:) function to add an item to Keychain. Below is an example on how to add an item to Keychain. @IBAction func AddButtonClicked(_ sender: Any) { let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } print(\"successfully saved\") } This is a goldilock example, meaning everything is setup correctly and no error's occurred, this of course will not happen everytime. In the case AddButtonClicked(_:) executes twice, you'd expect that Keychain will add another item into its database with duplicate data, right? Wrong! This will result in error errSecDuplicateItem: -25299 . Please read errSecDuplicateItem documentation to get a set of attributes (primary keys) that must be unique. In the following example, we are trying to store two kSecClassInternetPassword items in the Keychain. Since the set of kSecAttrAccount and kSecAttrServer are not unique between the items, the item2 will result in the errSecDuplicateItem error. let item1: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData ] let status = SecItemAdd(item1 as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } // ---- let item2: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData, kSecAttrLabel: \"some new label attribute\" ] let status2 = SecItemAdd(item2 as CFDictionary, nil) guard status2 == errSecSuccess else { print(\"status:\", status2) // status: -25299 return }","title":"Create Item"},{"location":"guides/understanding_keychain/#querying-items","text":"Note from Apple documentation : By default, your app can freely retrieve its own keychain items but not those of other apps. However, keychain services does provide mechanisms for broadening or narrowing that accessibility, for example, using the kSecAttrAccessGroup attribute. Use the SecItemCopyMatching(_:) function to query item(s) from Keychain. With the example below, take note that we are only searching across kSecAttrServer and not including kSecAttrAccount . @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem else { print(\"no Item\") // errSecItemNotFound: -25300 return } print(\"result: \\(item)\") } In the case where multiple accounts have the same kSecAttrServer set, we'd expect to see an array of items returned. But with the above example, only one item was returned. This is because by default SecItemCopyMatching(_:) only returns the first match found . If you would like to return all items that match the provided query, you must set kSecMatchLimit in the query. let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, // <-- // ... ] The two most important attributes when retrieving an item are: kSecReturnAttributes : must be set to true in order to retrieve item's attributes kSecReturnData : must be set to true in order to retrieve secret data. Even setting kSecReturnData: true and excluding kSecReturnAttributes , or setting it to false, will result in item returning as nil . let query: [CFString: Any] = [ //... kSecReturnAttributes: false, kSecReturnData: true ] // ... // prints: no Item","title":"Querying Item(s)"},{"location":"guides/understanding_keychain/#updating-item","text":"Use the SecItemUpdate(_:) function to update an item in Keychain. It is important to note that you should provide as many attributes to help Keychain filter what item to update. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be updated. @IBAction func updateClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\" ] let newAttributes: [CFString: Any] = [ kSecValueData: \"new-password\".data(using: String.Encoding.utf8)! ] let status = SecItemUpdate(query as CFDictionary, newAttributes as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully updated\") }","title":"Updating Item"},{"location":"guides/understanding_keychain/#deleting-item","text":"Use the SecItemDelete(_:) function to delete an item in Keychain. Just like when updating an item , you should provide as many attributes to help Keychain filter what item to delete. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be deleted. @IBAction func deleteClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\" ] let status = SecItemDelete(query as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully deleted\") }","title":"Deleting Item"},{"location":"guides/understanding_keychain/#accessibility","text":"In this section we will go over how to configure when your application has access to your Keychain items . For this, we set the kSecAttrAccessible attribute. By default, this attribute it set to kSecAttrAccessibleWhenUnlocked , but values for this attribute fall within two categories: Items that can be restored from a backup of another device. kSecAttrAccessibleWhenUnlocked kSecAttrAccessibleAfterFirstUnlock Items that cannot be restored from a backup of another device. kSecAttrAccessibleWhenUnlockedThisDeviceOnly kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly If you are using kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly \u2013 be prepared to encounter the errSecNotAvailable: -25291 error if the user does not have a passcode set. Here is where you can prompt the user that: \"They must set a device passcode in order to continue.\" Example let query: [CFString: Any] = [ kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked, // ... ]","title":"Accessibility"},{"location":"guides/understanding_keychain/#notes","text":"You must also provide the item's encrypted data, kSecValueData , anytime you wish to update the kSecAttrAccessible attribute in the future.","title":"Notes"},{"location":"guides/understanding_keychain/#add-faceidtouchid","text":"","title":"Add FaceID/TouchID"},{"location":"guides/understanding_keychain/#access-control","text":"In order to add biometrics such as FaceID or TouchID to a Keychain item, you must create a SecAccessControl object using the SecAccessControlCreateWithFlags(_:) function and set it the kSecAttrAccessControl attribute. example var error: Unmanaged<CFError>? = nil let accessControlObject = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: accessControlObject // ... ] // ...","title":"Access Control"},{"location":"guides/understanding_keychain/#flags","text":"In this section we will be going over some of the flags you can set and what errors you may encounter. In you want to see the entire list of flags, please checkout SecAccessControlCreateFlag for more information. Flags we will go over: .userPresence - FaceID/TouchID/Device Passcode. .devicePasscode - Device Passcode only. .biometryAny - FaceID/TouchID only (allows for biometrics changes). .biometryCurrentSet - FaceID/TouchID only (invalidates item when biometrics change). .applicationPassword - Application Specific password.","title":"Flags"},{"location":"guides/understanding_keychain/#nsfaceidusagedescription","text":"When using .userPresence , if NSFaceIDUsageDescription is not set in your plist, your application will revert to prompting the user for the Device Passcode. But when using .biometryAny or .biometryCurrentSet , failing to set NSFaceIDUsageDescription will result in your application crashing with the following error: ERROR: This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an NSFaceIDUsageDescription key with a string value explaining to the user how the app uses this data.","title":"NSFaceIDUsageDescription"},{"location":"guides/understanding_keychain/#userpresence","text":".userPresence is more than likely the flag you would be using in your application. Other flags such as .devicePasscode and .biometryAny , are simply slight derivatives of this flag. Above is the flow you can expect for your application to take when saving/retrieving a Keychain Item with the .userPresence flag. It is very possible to encounter errSecAuthFailed: -25293 errors when working with .userPresence flagged items. Please review the above flows for a better understanding. In addition to the Retrieving Flow , If the user adds back a passcode to the device (it doesn't have to be the same passcode) the item can once again be retrieved.","title":".userPresence"},{"location":"guides/understanding_keychain/#biometrycurrentset","text":"The flag that differs from .userPresence the most would be .biometryCurrentSet , it invalidates any Keychain Items once a finger is added/removed on TouchID or if the user re-enrolls for FaceID.","title":".biometryCurrentSet"},{"location":"guides/understanding_keychain/#applicationpassword","text":"The last flag we will go over is .applicationPassword , this allows for the user to set an application specific passcode in order to retrieve the item. When using this flag, iOS will prompt the user to insert a passcode. Meaning, you don't need to worry about providing a view to capture the application password. Unlike retrieving an item using device security such as .devicePasscode , after 5 failed attempts, Keychain returns the error errSecAuthFailed: -25293 instead of disabling the item retrieval. Meaning, after 5 failed attempts the user can simply try again without being penalized.","title":".applicationPassword"},{"location":"guides/understanding_keychain/#combining-flags","text":"In the case you want to authenticate the user with both .userPresence and .applicationPassword , you may combine them using an array. var error: Unmanaged<CFError>? = nil let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, [.userPresence, .applicationPassword], &error) Some combinations are not allowed such as [.userPresence, .devicePasscode] , so be sure to print out any errors for more information.","title":"Combining Flags"},{"location":"guides/understanding_keychain/#faceidtouchid-example","text":"In this example, we will create an item that will require FaceID, TouchID, or Passcode in order to be retrieved. @IBAction func saveWithAccessFlagClicked(_ sender: Any) { var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) else { return } let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: access, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully saved with access attribute\") } Next, we will retrieve the .userPresence flagged item. @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem, let username = item[kSecAttrAccount] as? String, let passwordData = item[kSecValueData] as? Data, let password = String(data: passwordData, encoding: .utf8) else { print(\"Item not found\") return } print(\"username:\", username) print(\"password:\", password) }","title":"FaceID/TouchID Example"},{"location":"guides/understanding_keychain/#ksecuseauthenticationuiskip","text":"When querying items from Keychain, you may be returned items that have the kSecAttrAccessControl attribute set, which will require the user to authenticate in order to retrieve the item. You can exclude these results by setting the kSecUseAuthenticationUI attribute in your query. @IBAction func QueryAllClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, kSecUseAuthenticationUI: kSecUseAuthenticationUISkip, ... ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) ...","title":"kSecUseAuthenticationUISkip"},{"location":"guides/understanding_keychain/#notes_1","text":"When setting a kSecAttrAccessControl attribute on your Keychain Item, you cannot set the kSecAttrAccessible attribute on the Keychain Item itself. Doing so will result in a errSecParam: -50 error, even if both are set to the same value. As an example, the following will return an error: var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, // <-- .userPresence, &error) else { return } let query: [CFString: Any] = [ kSecAttrAccessControl: access, kSecAttrAccessible:kSecAttrAccessibleWhenUnlocked, // <-- //... ] let status = SecItemAdd(query as CFDictionary, nil) // equals -50 (errSecParam)","title":"Notes"},{"location":"guides/understanding_keychain/#common-errors","text":"","title":"Common Errors"},{"location":"guides/understanding_keychain/#errsecitemnotfound-25300","text":"errSecItemNotFound , occurs when performing an Keychain operation such as SecItemCopyMatching(_:) , SecItemUpdate(_:) , or SecItemDelete(_:) and Keychain fails to find any matching items. In the case of SecItemUpdate(_:) and SecItemDelete(_:) , its best to query for the item before trying to perform an operation.","title":"errSecItemNotFound: -25300"},{"location":"guides/understanding_keychain/#errsecparam-50","text":"errSecParam , occurs when you fail to properly set an attribute. Where I see this happening the most is when you fail to properly encode the kSecValueData as CFData or you fail to provide a necessary attribute such as kSecClass . I would investigate those two attributes first when you encounter errSecParam .","title":"errSecParam: -50"},{"location":"guides/understanding_keychain/#errsecauthfailed-25293","text":"errSecAuthFailed , occurs when your application is trying to save an item that requires access control, but FaceID, TouchID, or Device Passcode are not setup on the device. Or if the user has removed the device's security since saving the item.","title":"errSecAuthFailed: -25293"},{"location":"guides/understanding_keychain/#errsecnosuchattr-25303","text":"errSecNoSuchAttr , occurs when you try to set an attribute that doesn't exist for the provided kSecClass . In the bottom example we try to set kSecAttrIssuer , which is only available for the kSecClassCertificate class. let password = \"some-password\".data(using: String.Encoding.utf8)! let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrIssuer: \"Fabian issuer\".data(using: String.Encoding.utf8)!, // kSecClassCertificate only kSecAttrServer: \"example.com\", kSecValueData: password ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: -25303 return }","title":"errSecNoSuchAttr: -25303"},{"location":"includes/advance_usage-celyAnimator/","text":".celyAnimator # In order to override the transition animations when loggin in, you must create a class / struct that conforms to the CelyAnimator protocol . Instead of transition from Left -> Right , in the example below we are transitioning from Top -> Bottom . Feel free to use any animation frameworks/libraries within loginTransition(_:) or logoutTransition(_:) . struct VerticalAnimator: CelyAnimator { func loginTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: 1000.0) }, completion: { (value: Bool) in snapshot.removeFromSuperview() }) } } func logoutTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: -1000.0) }, completion: {(value: Bool) in snapshot.removeFromSuperview() }) } } } Now to set this animation, add .celyAnimator to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .celyAnimator: VerticalAnimator() // ... ]) You application should now transition from Top -> Bottom :","title":"advance usage celyAnimator"},{"location":"includes/advance_usage-celyAnimator/#celyanimator","text":"In order to override the transition animations when loggin in, you must create a class / struct that conforms to the CelyAnimator protocol . Instead of transition from Left -> Right , in the example below we are transitioning from Top -> Bottom . Feel free to use any animation frameworks/libraries within loginTransition(_:) or logoutTransition(_:) . struct VerticalAnimator: CelyAnimator { func loginTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: 1000.0) }, completion: { (value: Bool) in snapshot.removeFromSuperview() }) } } func logoutTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: -1000.0) }, completion: {(value: Bool) in snapshot.removeFromSuperview() }) } } } Now to set this animation, add .celyAnimator to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .celyAnimator: VerticalAnimator() // ... ]) You application should now transition from Top -> Bottom :","title":".celyAnimator"},{"location":"includes/advance_usage-loginStyle/","text":".loginStyle # As of Cely's version 2.x.x, the built-in LoginViewController is more for rapid development/prototyping with the expectation that the developer will eventually configure Cely with their own LoginViewController . That's not to say that the role that Cely's built-in LoginViewController won't change in the future to include more customizable features and can become an overall end solution for some applications. As of this writing, simply create a class / struct that conforms to the CelyStyle . Please refer to CelyStyle for more information on what's customizable. Here is an example: struct CottonCandy: CelyStyle { func backgroundColor() -> UIColor { return UIColor(red: 86/255, green: 203/255, blue: 249/255, alpha: 1) } func buttonTextColor() -> UIColor { return .white } func buttonBackgroundColor() -> UIColor { return UIColor(red: 253/255, green: 108/255, blue: 179/255, alpha: 1) } func textFieldBackgroundColor() -> UIColor { return UIColor.white.withAlphaComponent(0.4) } func appLogo() -> UIImage? { return UIImage(named: \"CelyLogo\") } } Now to set this style, add .loginStyle to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginStyle: CottonCandy(), // ... ]) Your built-in screen should've changed to:","title":"advance usage loginStyle"},{"location":"includes/advance_usage-loginStyle/#loginstyle","text":"As of Cely's version 2.x.x, the built-in LoginViewController is more for rapid development/prototyping with the expectation that the developer will eventually configure Cely with their own LoginViewController . That's not to say that the role that Cely's built-in LoginViewController won't change in the future to include more customizable features and can become an overall end solution for some applications. As of this writing, simply create a class / struct that conforms to the CelyStyle . Please refer to CelyStyle for more information on what's customizable. Here is an example: struct CottonCandy: CelyStyle { func backgroundColor() -> UIColor { return UIColor(red: 86/255, green: 203/255, blue: 249/255, alpha: 1) } func buttonTextColor() -> UIColor { return .white } func buttonBackgroundColor() -> UIColor { return UIColor(red: 253/255, green: 108/255, blue: 179/255, alpha: 1) } func textFieldBackgroundColor() -> UIColor { return UIColor.white.withAlphaComponent(0.4) } func appLogo() -> UIImage? { return UIImage(named: \"CelyLogo\") } } Now to set this style, add .loginStyle to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginStyle: CottonCandy(), // ... ]) Your built-in screen should've changed to:","title":".loginStyle"},{"location":"includes/advance_usage-loginViewController/","text":".loginViewController # To use your own login, set the custom Login ViewController as .loginViewController inside of the withOptions in Cely.setup(_:) . // iOS 13 | Swift 5.0 | Xcode 11.0 Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginViewController: UIHostingController(rootView: LoginContentView()) ])","title":"advance usage loginViewController"},{"location":"includes/advance_usage-loginViewController/#loginviewcontroller","text":"To use your own login, set the custom Login ViewController as .loginViewController inside of the withOptions in Cely.setup(_:) . // iOS 13 | Swift 5.0 | Xcode 11.0 Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginViewController: UIHostingController(rootView: LoginContentView()) ])","title":".loginViewController"},{"location":"includes/installing-cely/","text":"Requirements # iOS 11.0+ Xcode 9.0+ Swift 4.0+ Carthage # Carthage is a decentralized dependency manager that automates the process of adding frameworks to your Cocoa application. You can install Carthage with Homebrew using the following command: $ brew update $ brew install carthage To integrate Cely into your Xcode project using Carthage, specify it in your Cartfile : github \"initFabian/Cely\" ~> 2.1 CocoaPods # CocoaPods is a dependency manager for Cocoa projects. You can install it with the following command: $ gem install cocoapods To integrate Cely into your Xcode project using CocoaPods, specify it in your Podfile : source 'https://github.com/CocoaPods/Specs.git' platform :ios, '8.0' use_frameworks! pod 'Cely', '~> 2.1' Then, run the following command: $ pod install","title":"Installation"},{"location":"includes/installing-cely/#requirements","text":"iOS 11.0+ Xcode 9.0+ Swift 4.0+","title":"Requirements"},{"location":"includes/installing-cely/#carthage","text":"Carthage is a decentralized dependency manager that automates the process of adding frameworks to your Cocoa application. You can install Carthage with Homebrew using the following command: $ brew update $ brew install carthage To integrate Cely into your Xcode project using Carthage, specify it in your Cartfile : github \"initFabian/Cely\" ~> 2.1","title":"Carthage"},{"location":"includes/installing-cely/#cocoapods","text":"CocoaPods is a dependency manager for Cocoa projects. You can install it with the following command: $ gem install cocoapods To integrate Cely into your Xcode project using CocoaPods, specify it in your Podfile : source 'https://github.com/CocoaPods/Specs.git' platform :ios, '8.0' use_frameworks! pod 'Cely', '~> 2.1' Then, run the following command: $ pod install","title":"CocoaPods"},{"location":"includes/keychain-wrapper-usage/","text":"Most applications that work with Keychain Services , use it to store sensitive information such as user credentials and tokens. When working with Keychain, you typically would find yourself using a framework like KeychainAccess , Locksmith , or keychain-swift . Even tutorials from some of the most reputable online resources encourage the use of these frameworks. Even Apple provides a wrapper around keychain.","title":"Keychain wrapper usage"},{"location":"includes/why-cely/","text":"Why Cely # Cely's goal is to add a secure login system into your app in under 30 seconds! Background # Most applications that work with Keychain Services , use it to store sensitive information such as user credentials and tokens. When working with Keychain, you typically would find yourself using a framework like KeychainAccess , Locksmith , or keychain-swift . Even tutorials from some of the most reputable online resources encourage the use of these frameworks. Even Apple provides a wrapper around keychain. This is no coincidence either, Keychain Service is apart of Apple's lower level Security Framework which is written in C. I too would encourage you to use a framework instead of interfacing with this API directly. There's no need to reinvent the wheel when working with this API. But if you must, I suggest you bookmark osstatus.com to help you decipher all the possible OSStatus error codes your app will encounter. But storing information securely is only one half of the solution , the other half is building a Login system . This Login system will be an entirely different part of your codebase that will be responsible for interacting with your application's UIWindow , handle abrupt login status change (redirect to login screen), update Keychain, etc. This is where Cely comes in, it solves both problems by combining these two entirely different bits of functionality into one seamless all-in-one solution.","title":"Why cely"},{"location":"includes/why-cely/#why-cely","text":"Cely's goal is to add a secure login system into your app in under 30 seconds!","title":"Why Cely"},{"location":"includes/why-cely/#background","text":"Most applications that work with Keychain Services , use it to store sensitive information such as user credentials and tokens. When working with Keychain, you typically would find yourself using a framework like KeychainAccess , Locksmith , or keychain-swift . Even tutorials from some of the most reputable online resources encourage the use of these frameworks. Even Apple provides a wrapper around keychain. This is no coincidence either, Keychain Service is apart of Apple's lower level Security Framework which is written in C. I too would encourage you to use a framework instead of interfacing with this API directly. There's no need to reinvent the wheel when working with this API. But if you must, I suggest you bookmark osstatus.com to help you decipher all the possible OSStatus error codes your app will encounter. But storing information securely is only one half of the solution , the other half is building a Login system . This Login system will be an entirely different part of your codebase that will be responsible for interacting with your application's UIWindow , handle abrupt login status change (redirect to login screen), update Keychain, etc. This is where Cely comes in, it solves both problems by combining these two entirely different bits of functionality into one seamless all-in-one solution.","title":"Background"},{"location":"includes/understanding_keychain/0_keychain-anatomy/","text":"Keychain Anatomy # Note Keychain Services expects Core Foundation objects, hence the CF prefix on some of the properties/attributes, such as CFDictionary , CFData , etc. Don't be intimidated, you can still use the Data type since Apple has bridges for these types. Read Tool-Free Bridging for more information. The Keychain is an encrypted database stored on disk consistenting of Keychain Items . A Keychain Item is made up of attributes and the data you wish to encrypt. kSecClass # The kSecClass attribute describes to Keychain what classification an item is, and determines what other attributes can be stored with your item. For example, if your application was storing a certificate, you would use the kSecClassCertificate class attribute. This attribute tells Keychain what other attributes can be set on your item, such as kSecAttrIssuer and kSecAttrPublicKeyHash . Trying to set an attribute that doesn't exist on the kSecClass attribute will result in OSStatus code errSecNoSuchAttr: -25303 . Also, not setting the kSecClass key in your Keychain Item will result in OSStatus error errSecParam: -50 . Below are the available options for the kSecClass key: kSecClassGenericPassword kSecClassInternetPassword kSecClassCertificate kSecClassKey kSecClassIdentity If you want to see all available attributes regardless of class, here is the list .","title":"0 keychain anatomy"},{"location":"includes/understanding_keychain/0_keychain-anatomy/#keychain-anatomy","text":"Note Keychain Services expects Core Foundation objects, hence the CF prefix on some of the properties/attributes, such as CFDictionary , CFData , etc. Don't be intimidated, you can still use the Data type since Apple has bridges for these types. Read Tool-Free Bridging for more information. The Keychain is an encrypted database stored on disk consistenting of Keychain Items . A Keychain Item is made up of attributes and the data you wish to encrypt.","title":"Keychain Anatomy"},{"location":"includes/understanding_keychain/0_keychain-anatomy/#ksecclass","text":"The kSecClass attribute describes to Keychain what classification an item is, and determines what other attributes can be stored with your item. For example, if your application was storing a certificate, you would use the kSecClassCertificate class attribute. This attribute tells Keychain what other attributes can be set on your item, such as kSecAttrIssuer and kSecAttrPublicKeyHash . Trying to set an attribute that doesn't exist on the kSecClass attribute will result in OSStatus code errSecNoSuchAttr: -25303 . Also, not setting the kSecClass key in your Keychain Item will result in OSStatus error errSecParam: -50 . Below are the available options for the kSecClass key: kSecClassGenericPassword kSecClassInternetPassword kSecClassCertificate kSecClassKey kSecClassIdentity If you want to see all available attributes regardless of class, here is the list .","title":"kSecClass"},{"location":"includes/understanding_keychain/1_create-item/","text":"Create Item # Use the SecItemAdd(_:) function to add an item to Keychain. Below is an example on how to add an item to Keychain. @IBAction func AddButtonClicked(_ sender: Any) { let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } print(\"successfully saved\") } This is a goldilock example, meaning everything is setup correctly and no error's occurred, this of course will not happen everytime. In the case AddButtonClicked(_:) executes twice, you'd expect that Keychain will add another item into its database with duplicate data, right? Wrong! This will result in error errSecDuplicateItem: -25299 . Please read errSecDuplicateItem documentation to get a set of attributes (primary keys) that must be unique. In the following example, we are trying to store two kSecClassInternetPassword items in the Keychain. Since the set of kSecAttrAccount and kSecAttrServer are not unique between the items, the item2 will result in the errSecDuplicateItem error. let item1: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData ] let status = SecItemAdd(item1 as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } // ---- let item2: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData, kSecAttrLabel: \"some new label attribute\" ] let status2 = SecItemAdd(item2 as CFDictionary, nil) guard status2 == errSecSuccess else { print(\"status:\", status2) // status: -25299 return }","title":"1 create item"},{"location":"includes/understanding_keychain/1_create-item/#create-item","text":"Use the SecItemAdd(_:) function to add an item to Keychain. Below is an example on how to add an item to Keychain. @IBAction func AddButtonClicked(_ sender: Any) { let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } print(\"successfully saved\") } This is a goldilock example, meaning everything is setup correctly and no error's occurred, this of course will not happen everytime. In the case AddButtonClicked(_:) executes twice, you'd expect that Keychain will add another item into its database with duplicate data, right? Wrong! This will result in error errSecDuplicateItem: -25299 . Please read errSecDuplicateItem documentation to get a set of attributes (primary keys) that must be unique. In the following example, we are trying to store two kSecClassInternetPassword items in the Keychain. Since the set of kSecAttrAccount and kSecAttrServer are not unique between the items, the item2 will result in the errSecDuplicateItem error. let item1: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData ] let status = SecItemAdd(item1 as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: 0 return } // ---- let item2: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: account, kSecAttrServer: \"example.com\", kSecValueData: passwordData, kSecAttrLabel: \"some new label attribute\" ] let status2 = SecItemAdd(item2 as CFDictionary, nil) guard status2 == errSecSuccess else { print(\"status:\", status2) // status: -25299 return }","title":"Create Item"},{"location":"includes/understanding_keychain/2_get-item/","text":"Querying Item(s) # Note from Apple documentation : By default, your app can freely retrieve its own keychain items but not those of other apps. However, keychain services does provide mechanisms for broadening or narrowing that accessibility, for example, using the kSecAttrAccessGroup attribute. Use the SecItemCopyMatching(_:) function to query item(s) from Keychain. With the example below, take note that we are only searching across kSecAttrServer and not including kSecAttrAccount . @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem else { print(\"no Item\") // errSecItemNotFound: -25300 return } print(\"result: \\(item)\") } In the case where multiple accounts have the same kSecAttrServer set, we'd expect to see an array of items returned. But with the above example, only one item was returned. This is because by default SecItemCopyMatching(_:) only returns the first match found . If you would like to return all items that match the provided query, you must set kSecMatchLimit in the query. let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, // <-- // ... ] The two most important attributes when retrieving an item are: kSecReturnAttributes : must be set to true in order to retrieve item's attributes kSecReturnData : must be set to true in order to retrieve secret data. Even setting kSecReturnData: true and excluding kSecReturnAttributes , or setting it to false, will result in item returning as nil . let query: [CFString: Any] = [ //... kSecReturnAttributes: false, kSecReturnData: true ] // ... // prints: no Item","title":"2 get item"},{"location":"includes/understanding_keychain/2_get-item/#querying-items","text":"Note from Apple documentation : By default, your app can freely retrieve its own keychain items but not those of other apps. However, keychain services does provide mechanisms for broadening or narrowing that accessibility, for example, using the kSecAttrAccessGroup attribute. Use the SecItemCopyMatching(_:) function to query item(s) from Keychain. With the example below, take note that we are only searching across kSecAttrServer and not including kSecAttrAccount . @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem else { print(\"no Item\") // errSecItemNotFound: -25300 return } print(\"result: \\(item)\") } In the case where multiple accounts have the same kSecAttrServer set, we'd expect to see an array of items returned. But with the above example, only one item was returned. This is because by default SecItemCopyMatching(_:) only returns the first match found . If you would like to return all items that match the provided query, you must set kSecMatchLimit in the query. let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, // <-- // ... ] The two most important attributes when retrieving an item are: kSecReturnAttributes : must be set to true in order to retrieve item's attributes kSecReturnData : must be set to true in order to retrieve secret data. Even setting kSecReturnData: true and excluding kSecReturnAttributes , or setting it to false, will result in item returning as nil . let query: [CFString: Any] = [ //... kSecReturnAttributes: false, kSecReturnData: true ] // ... // prints: no Item","title":"Querying Item(s)"},{"location":"includes/understanding_keychain/3_update-item/","text":"Updating Item # Use the SecItemUpdate(_:) function to update an item in Keychain. It is important to note that you should provide as many attributes to help Keychain filter what item to update. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be updated. @IBAction func updateClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\" ] let newAttributes: [CFString: Any] = [ kSecValueData: \"new-password\".data(using: String.Encoding.utf8)! ] let status = SecItemUpdate(query as CFDictionary, newAttributes as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully updated\") }","title":"3 update item"},{"location":"includes/understanding_keychain/3_update-item/#updating-item","text":"Use the SecItemUpdate(_:) function to update an item in Keychain. It is important to note that you should provide as many attributes to help Keychain filter what item to update. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be updated. @IBAction func updateClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\" ] let newAttributes: [CFString: Any] = [ kSecValueData: \"new-password\".data(using: String.Encoding.utf8)! ] let status = SecItemUpdate(query as CFDictionary, newAttributes as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully updated\") }","title":"Updating Item"},{"location":"includes/understanding_keychain/4_delete-item/","text":"Deleting Item # Use the SecItemDelete(_:) function to delete an item in Keychain. Just like when updating an item , you should provide as many attributes to help Keychain filter what item to delete. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be deleted. @IBAction func deleteClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\" ] let status = SecItemDelete(query as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully deleted\") }","title":"4 delete item"},{"location":"includes/understanding_keychain/4_delete-item/#deleting-item","text":"Use the SecItemDelete(_:) function to delete an item in Keychain. Just like when updating an item , you should provide as many attributes to help Keychain filter what item to delete. In the case where a user has multiple accounts stored in Keychain and you simply queried for kSecAttrServer and kSecClass , all Keychain Items that match that query will be deleted. @IBAction func deleteClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrServer: \"example.com\" ] let status = SecItemDelete(query as CFDictionary) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully deleted\") }","title":"Deleting Item"},{"location":"includes/understanding_keychain/5_accessibility/","text":"Accessibility # In this section we will go over how to configure when your application has access to your Keychain items . For this, we set the kSecAttrAccessible attribute. By default, this attribute it set to kSecAttrAccessibleWhenUnlocked , but values for this attribute fall within two categories: Items that can be restored from a backup of another device. kSecAttrAccessibleWhenUnlocked kSecAttrAccessibleAfterFirstUnlock Items that cannot be restored from a backup of another device. kSecAttrAccessibleWhenUnlockedThisDeviceOnly kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly If you are using kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly \u2013 be prepared to encounter the errSecNotAvailable: -25291 error if the user does not have a passcode set. Here is where you can prompt the user that: \"They must set a device passcode in order to continue.\" Example let query: [CFString: Any] = [ kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked, // ... ] Notes # You must also provide the item's encrypted data, kSecValueData , anytime you wish to update the kSecAttrAccessible attribute in the future.","title":"5 accessibility"},{"location":"includes/understanding_keychain/5_accessibility/#accessibility","text":"In this section we will go over how to configure when your application has access to your Keychain items . For this, we set the kSecAttrAccessible attribute. By default, this attribute it set to kSecAttrAccessibleWhenUnlocked , but values for this attribute fall within two categories: Items that can be restored from a backup of another device. kSecAttrAccessibleWhenUnlocked kSecAttrAccessibleAfterFirstUnlock Items that cannot be restored from a backup of another device. kSecAttrAccessibleWhenUnlockedThisDeviceOnly kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly If you are using kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly \u2013 be prepared to encounter the errSecNotAvailable: -25291 error if the user does not have a passcode set. Here is where you can prompt the user that: \"They must set a device passcode in order to continue.\" Example let query: [CFString: Any] = [ kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked, // ... ]","title":"Accessibility"},{"location":"includes/understanding_keychain/5_accessibility/#notes","text":"You must also provide the item's encrypted data, kSecValueData , anytime you wish to update the kSecAttrAccessible attribute in the future.","title":"Notes"},{"location":"includes/understanding_keychain/6_access-control/","text":"Add FaceID/TouchID # Access Control # In order to add biometrics such as FaceID or TouchID to a Keychain item, you must create a SecAccessControl object using the SecAccessControlCreateWithFlags(_:) function and set it the kSecAttrAccessControl attribute. example var error: Unmanaged<CFError>? = nil let accessControlObject = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: accessControlObject // ... ] // ... Flags # In this section we will be going over some of the flags you can set and what errors you may encounter. In you want to see the entire list of flags, please checkout SecAccessControlCreateFlag for more information. Flags we will go over: .userPresence - FaceID/TouchID/Device Passcode. .devicePasscode - Device Passcode only. .biometryAny - FaceID/TouchID only (allows for biometrics changes). .biometryCurrentSet - FaceID/TouchID only (invalidates item when biometrics change). .applicationPassword - Application Specific password. NSFaceIDUsageDescription # When using .userPresence , if NSFaceIDUsageDescription is not set in your plist, your application will revert to prompting the user for the Device Passcode. But when using .biometryAny or .biometryCurrentSet , failing to set NSFaceIDUsageDescription will result in your application crashing with the following error: ERROR: This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an NSFaceIDUsageDescription key with a string value explaining to the user how the app uses this data. .userPresence # .userPresence is more than likely the flag you would be using in your application. Other flags such as .devicePasscode and .biometryAny , are simply slight derivatives of this flag. Above is the flow you can expect for your application to take when saving/retrieving a Keychain Item with the .userPresence flag. It is very possible to encounter errSecAuthFailed: -25293 errors when working with .userPresence flagged items. Please review the above flows for a better understanding. In addition to the Retrieving Flow , If the user adds back a passcode to the device (it doesn't have to be the same passcode) the item can once again be retrieved. .biometryCurrentSet # The flag that differs from .userPresence the most would be .biometryCurrentSet , it invalidates any Keychain Items once a finger is added/removed on TouchID or if the user re-enrolls for FaceID. .applicationPassword # The last flag we will go over is .applicationPassword , this allows for the user to set an application specific passcode in order to retrieve the item. When using this flag, iOS will prompt the user to insert a passcode. Meaning, you don't need to worry about providing a view to capture the application password. Unlike retrieving an item using device security such as .devicePasscode , after 5 failed attempts, Keychain returns the error errSecAuthFailed: -25293 instead of disabling the item retrieval. Meaning, after 5 failed attempts the user can simply try again without being penalized. Combining Flags # In the case you want to authenticate the user with both .userPresence and .applicationPassword , you may combine them using an array. var error: Unmanaged<CFError>? = nil let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, [.userPresence, .applicationPassword], &error) Some combinations are not allowed such as [.userPresence, .devicePasscode] , so be sure to print out any errors for more information. FaceID/TouchID Example # In this example, we will create an item that will require FaceID, TouchID, or Passcode in order to be retrieved. @IBAction func saveWithAccessFlagClicked(_ sender: Any) { var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) else { return } let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: access, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully saved with access attribute\") } Next, we will retrieve the .userPresence flagged item. @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem, let username = item[kSecAttrAccount] as? String, let passwordData = item[kSecValueData] as? Data, let password = String(data: passwordData, encoding: .utf8) else { print(\"Item not found\") return } print(\"username:\", username) print(\"password:\", password) } kSecUseAuthenticationUISkip # When querying items from Keychain, you may be returned items that have the kSecAttrAccessControl attribute set, which will require the user to authenticate in order to retrieve the item. You can exclude these results by setting the kSecUseAuthenticationUI attribute in your query. @IBAction func QueryAllClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, kSecUseAuthenticationUI: kSecUseAuthenticationUISkip, ... ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) ... Notes # When setting a kSecAttrAccessControl attribute on your Keychain Item, you cannot set the kSecAttrAccessible attribute on the Keychain Item itself. Doing so will result in a errSecParam: -50 error, even if both are set to the same value. As an example, the following will return an error: var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, // <-- .userPresence, &error) else { return } let query: [CFString: Any] = [ kSecAttrAccessControl: access, kSecAttrAccessible:kSecAttrAccessibleWhenUnlocked, // <-- //... ] let status = SecItemAdd(query as CFDictionary, nil) // equals -50 (errSecParam)","title":"6 access control"},{"location":"includes/understanding_keychain/6_access-control/#add-faceidtouchid","text":"","title":"Add FaceID/TouchID"},{"location":"includes/understanding_keychain/6_access-control/#access-control","text":"In order to add biometrics such as FaceID or TouchID to a Keychain item, you must create a SecAccessControl object using the SecAccessControlCreateWithFlags(_:) function and set it the kSecAttrAccessControl attribute. example var error: Unmanaged<CFError>? = nil let accessControlObject = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: accessControlObject // ... ] // ...","title":"Access Control"},{"location":"includes/understanding_keychain/6_access-control/#flags","text":"In this section we will be going over some of the flags you can set and what errors you may encounter. In you want to see the entire list of flags, please checkout SecAccessControlCreateFlag for more information. Flags we will go over: .userPresence - FaceID/TouchID/Device Passcode. .devicePasscode - Device Passcode only. .biometryAny - FaceID/TouchID only (allows for biometrics changes). .biometryCurrentSet - FaceID/TouchID only (invalidates item when biometrics change). .applicationPassword - Application Specific password.","title":"Flags"},{"location":"includes/understanding_keychain/6_access-control/#nsfaceidusagedescription","text":"When using .userPresence , if NSFaceIDUsageDescription is not set in your plist, your application will revert to prompting the user for the Device Passcode. But when using .biometryAny or .biometryCurrentSet , failing to set NSFaceIDUsageDescription will result in your application crashing with the following error: ERROR: This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an NSFaceIDUsageDescription key with a string value explaining to the user how the app uses this data.","title":"NSFaceIDUsageDescription"},{"location":"includes/understanding_keychain/6_access-control/#userpresence","text":".userPresence is more than likely the flag you would be using in your application. Other flags such as .devicePasscode and .biometryAny , are simply slight derivatives of this flag. Above is the flow you can expect for your application to take when saving/retrieving a Keychain Item with the .userPresence flag. It is very possible to encounter errSecAuthFailed: -25293 errors when working with .userPresence flagged items. Please review the above flows for a better understanding. In addition to the Retrieving Flow , If the user adds back a passcode to the device (it doesn't have to be the same passcode) the item can once again be retrieved.","title":".userPresence"},{"location":"includes/understanding_keychain/6_access-control/#biometrycurrentset","text":"The flag that differs from .userPresence the most would be .biometryCurrentSet , it invalidates any Keychain Items once a finger is added/removed on TouchID or if the user re-enrolls for FaceID.","title":".biometryCurrentSet"},{"location":"includes/understanding_keychain/6_access-control/#applicationpassword","text":"The last flag we will go over is .applicationPassword , this allows for the user to set an application specific passcode in order to retrieve the item. When using this flag, iOS will prompt the user to insert a passcode. Meaning, you don't need to worry about providing a view to capture the application password. Unlike retrieving an item using device security such as .devicePasscode , after 5 failed attempts, Keychain returns the error errSecAuthFailed: -25293 instead of disabling the item retrieval. Meaning, after 5 failed attempts the user can simply try again without being penalized.","title":".applicationPassword"},{"location":"includes/understanding_keychain/6_access-control/#combining-flags","text":"In the case you want to authenticate the user with both .userPresence and .applicationPassword , you may combine them using an array. var error: Unmanaged<CFError>? = nil let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, [.userPresence, .applicationPassword], &error) Some combinations are not allowed such as [.userPresence, .devicePasscode] , so be sure to print out any errors for more information.","title":"Combining Flags"},{"location":"includes/understanding_keychain/6_access-control/#faceidtouchid-example","text":"In this example, we will create an item that will require FaceID, TouchID, or Passcode in order to be retrieved. @IBAction func saveWithAccessFlagClicked(_ sender: Any) { var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, .userPresence, &error) else { return } let item: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccessControl: access, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecValueData: \"some-password\".data(using: String.Encoding.utf8)! ] let status = SecItemAdd(item as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) return } print(\"successfully saved with access attribute\") } Next, we will retrieve the .userPresence flagged item. @IBAction func QueryClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \"example.com\", kSecAttrAccount: \"username\", kSecReturnAttributes: true, kSecReturnData: true ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) guard status == errSecSuccess else { print(\"status:\", status) return } guard let item = someItem, let username = item[kSecAttrAccount] as? String, let passwordData = item[kSecValueData] as? Data, let password = String(data: passwordData, encoding: .utf8) else { print(\"Item not found\") return } print(\"username:\", username) print(\"password:\", password) }","title":"FaceID/TouchID Example"},{"location":"includes/understanding_keychain/6_access-control/#ksecuseauthenticationuiskip","text":"When querying items from Keychain, you may be returned items that have the kSecAttrAccessControl attribute set, which will require the user to authenticate in order to retrieve the item. You can exclude these results by setting the kSecUseAuthenticationUI attribute in your query. @IBAction func QueryAllClicked(_ sender: Any) { let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecMatchLimit: kSecMatchLimitAll, kSecUseAuthenticationUI: kSecUseAuthenticationUISkip, ... ] var someItem: CFTypeRef? let status = SecItemCopyMatching(query as CFDictionary, &someItem) ...","title":"kSecUseAuthenticationUISkip"},{"location":"includes/understanding_keychain/6_access-control/#notes","text":"When setting a kSecAttrAccessControl attribute on your Keychain Item, you cannot set the kSecAttrAccessible attribute on the Keychain Item itself. Doing so will result in a errSecParam: -50 error, even if both are set to the same value. As an example, the following will return an error: var error: Unmanaged<CFError>? = nil guard let access = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlocked, // <-- .userPresence, &error) else { return } let query: [CFString: Any] = [ kSecAttrAccessControl: access, kSecAttrAccessible:kSecAttrAccessibleWhenUnlocked, // <-- //... ] let status = SecItemAdd(query as CFDictionary, nil) // equals -50 (errSecParam)","title":"Notes"},{"location":"includes/understanding_keychain/7_common-errors/","text":"Common Errors # errSecItemNotFound: -25300 # errSecItemNotFound , occurs when performing an Keychain operation such as SecItemCopyMatching(_:) , SecItemUpdate(_:) , or SecItemDelete(_:) and Keychain fails to find any matching items. In the case of SecItemUpdate(_:) and SecItemDelete(_:) , its best to query for the item before trying to perform an operation. errSecParam: -50 # errSecParam , occurs when you fail to properly set an attribute. Where I see this happening the most is when you fail to properly encode the kSecValueData as CFData or you fail to provide a necessary attribute such as kSecClass . I would investigate those two attributes first when you encounter errSecParam . errSecAuthFailed: -25293 # errSecAuthFailed , occurs when your application is trying to save an item that requires access control, but FaceID, TouchID, or Device Passcode are not setup on the device. Or if the user has removed the device's security since saving the item. errSecNoSuchAttr: -25303 # errSecNoSuchAttr , occurs when you try to set an attribute that doesn't exist for the provided kSecClass . In the bottom example we try to set kSecAttrIssuer , which is only available for the kSecClassCertificate class. let password = \"some-password\".data(using: String.Encoding.utf8)! let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrIssuer: \"Fabian issuer\".data(using: String.Encoding.utf8)!, // kSecClassCertificate only kSecAttrServer: \"example.com\", kSecValueData: password ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: -25303 return }","title":"7 common errors"},{"location":"includes/understanding_keychain/7_common-errors/#common-errors","text":"","title":"Common Errors"},{"location":"includes/understanding_keychain/7_common-errors/#errsecitemnotfound-25300","text":"errSecItemNotFound , occurs when performing an Keychain operation such as SecItemCopyMatching(_:) , SecItemUpdate(_:) , or SecItemDelete(_:) and Keychain fails to find any matching items. In the case of SecItemUpdate(_:) and SecItemDelete(_:) , its best to query for the item before trying to perform an operation.","title":"errSecItemNotFound: -25300"},{"location":"includes/understanding_keychain/7_common-errors/#errsecparam-50","text":"errSecParam , occurs when you fail to properly set an attribute. Where I see this happening the most is when you fail to properly encode the kSecValueData as CFData or you fail to provide a necessary attribute such as kSecClass . I would investigate those two attributes first when you encounter errSecParam .","title":"errSecParam: -50"},{"location":"includes/understanding_keychain/7_common-errors/#errsecauthfailed-25293","text":"errSecAuthFailed , occurs when your application is trying to save an item that requires access control, but FaceID, TouchID, or Device Passcode are not setup on the device. Or if the user has removed the device's security since saving the item.","title":"errSecAuthFailed: -25293"},{"location":"includes/understanding_keychain/7_common-errors/#errsecnosuchattr-25303","text":"errSecNoSuchAttr , occurs when you try to set an attribute that doesn't exist for the provided kSecClass . In the bottom example we try to set kSecAttrIssuer , which is only available for the kSecClassCertificate class. let password = \"some-password\".data(using: String.Encoding.utf8)! let query: [CFString: Any] = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \"username\", kSecAttrIssuer: \"Fabian issuer\".data(using: String.Encoding.utf8)!, // kSecClassCertificate only kSecAttrServer: \"example.com\", kSecValueData: password ] let status = SecItemAdd(query as CFDictionary, nil) guard status == errSecSuccess else { print(\"status:\", status) // status: -25303 return }","title":"errSecNoSuchAttr: -25303"},{"location":"usage/advance_usage/","text":"The power of Cely's configuration comes from its enum dictionary for CelyOptions . Below are sections to go over these options. .loginViewController # To use your own login, set the custom Login ViewController as .loginViewController inside of the withOptions in Cely.setup(_:) . // iOS 13 | Swift 5.0 | Xcode 11.0 Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginViewController: UIHostingController(rootView: LoginContentView()) ]) .loginStyle # As of Cely's version 2.x.x, the built-in LoginViewController is more for rapid development/prototyping with the expectation that the developer will eventually configure Cely with their own LoginViewController . That's not to say that the role that Cely's built-in LoginViewController won't change in the future to include more customizable features and can become an overall end solution for some applications. As of this writing, simply create a class / struct that conforms to the CelyStyle . Please refer to CelyStyle for more information on what's customizable. Here is an example: struct CottonCandy: CelyStyle { func backgroundColor() -> UIColor { return UIColor(red: 86/255, green: 203/255, blue: 249/255, alpha: 1) } func buttonTextColor() -> UIColor { return .white } func buttonBackgroundColor() -> UIColor { return UIColor(red: 253/255, green: 108/255, blue: 179/255, alpha: 1) } func textFieldBackgroundColor() -> UIColor { return UIColor.white.withAlphaComponent(0.4) } func appLogo() -> UIImage? { return UIImage(named: \"CelyLogo\") } } Now to set this style, add .loginStyle to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginStyle: CottonCandy(), // ... ]) Your built-in screen should've changed to: .celyAnimator # In order to override the transition animations when loggin in, you must create a class / struct that conforms to the CelyAnimator protocol . Instead of transition from Left -> Right , in the example below we are transitioning from Top -> Bottom . Feel free to use any animation frameworks/libraries within loginTransition(_:) or logoutTransition(_:) . struct VerticalAnimator: CelyAnimator { func loginTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: 1000.0) }, completion: { (value: Bool) in snapshot.removeFromSuperview() }) } } func logoutTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: -1000.0) }, completion: {(value: Bool) in snapshot.removeFromSuperview() }) } } } Now to set this animation, add .celyAnimator to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .celyAnimator: VerticalAnimator() // ... ]) You application should now transition from Top -> Bottom :","title":"Advance"},{"location":"usage/advance_usage/#loginviewcontroller","text":"To use your own login, set the custom Login ViewController as .loginViewController inside of the withOptions in Cely.setup(_:) . // iOS 13 | Swift 5.0 | Xcode 11.0 Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginViewController: UIHostingController(rootView: LoginContentView()) ])","title":".loginViewController"},{"location":"usage/advance_usage/#loginstyle","text":"As of Cely's version 2.x.x, the built-in LoginViewController is more for rapid development/prototyping with the expectation that the developer will eventually configure Cely with their own LoginViewController . That's not to say that the role that Cely's built-in LoginViewController won't change in the future to include more customizable features and can become an overall end solution for some applications. As of this writing, simply create a class / struct that conforms to the CelyStyle . Please refer to CelyStyle for more information on what's customizable. Here is an example: struct CottonCandy: CelyStyle { func backgroundColor() -> UIColor { return UIColor(red: 86/255, green: 203/255, blue: 249/255, alpha: 1) } func buttonTextColor() -> UIColor { return .white } func buttonBackgroundColor() -> UIColor { return UIColor(red: 253/255, green: 108/255, blue: 179/255, alpha: 1) } func textFieldBackgroundColor() -> UIColor { return UIColor.white.withAlphaComponent(0.4) } func appLogo() -> UIImage? { return UIImage(named: \"CelyLogo\") } } Now to set this style, add .loginStyle to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .loginStyle: CottonCandy(), // ... ]) Your built-in screen should've changed to:","title":".loginStyle"},{"location":"usage/advance_usage/#celyanimator","text":"In order to override the transition animations when loggin in, you must create a class / struct that conforms to the CelyAnimator protocol . Instead of transition from Left -> Right , in the example below we are transitioning from Top -> Bottom . Feel free to use any animation frameworks/libraries within loginTransition(_:) or logoutTransition(_:) . struct VerticalAnimator: CelyAnimator { func loginTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: 1000.0) }, completion: { (value: Bool) in snapshot.removeFromSuperview() }) } } func logoutTransition(to destinationVC: UIViewController?, with celyWindow: UIWindow) { if let snapshot = celyWindow.snapshotView(afterScreenUpdates: true) { destinationVC?.view.addSubview(snapshot) celyWindow.setCurrentViewController(to: destinationVC) UIView.animate(withDuration: 0.5, animations: { snapshot.transform = CGAffineTransform(translationX: 0.0, y: -1000.0) }, completion: {(value: Bool) in snapshot.removeFromSuperview() }) } } } Now to set this animation, add .celyAnimator to withOptions: in Cely.setup(_:) : // AppDelegate.swift Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .celyAnimator: VerticalAnimator() // ... ]) You application should now transition from Top -> Bottom :","title":".celyAnimator"},{"location":"usage/basic_usage/","text":"Overview # Introduction # With the recent changes made to the App's Life Cycle , depending on what version of iOS your application will support, you will need to call Cely.setup(_:) in either your AppDelegate ( iOS 12 and earlier ) or SceneDelegate ( iOS 13 and later ). The rest of the guide will follow as if your application supports iOS 13 & later. Cely has a few defaults to help with speedy development, one of which is to include a built-in LoginViewController . If you would like to use your own, checkout setup own LoginViewController . Cely Setup # Let's start by creating a User model that conforms to the CelyUser Protocol: import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } In your application's SceneDelegate.swift , paste the following: // iOS 13 | Swift 5.0 | Xcode 11.0 import Cely class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginCompletionBlock: { (username: String, password: String) in if username == \"hello\" && password == \"world\" { // Store credentials and login print(\"Logging in...\") } } ]) } } } Now hit RUN on Xcode. You should see Cely's default login screen. Provide the credentials below and click Login . username: hello password: world Save Credentials # Next, we need to save the credentials to Cely's secure storage using Cely.credentials . Finally, set the CelyStatus to .loggedIn to trigger your application to login. if username == \"hello\" && password == \"world\" { Cely.save(\"FAKETOKEN\", forKey: \"token\", securely: true) Cely.credentials.set( username: username, password: password, server: \"api.example.com\" ) Cely.changeStatus(to: .loggedIn) } Code: # // iOS 13 | Swift 5.0 | Xcode 11.0 import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ // Application entry point .homeViewController: UIHostingController(rootView: HomeContentView()), // handle Cely's default loginViewController event .loginCompletionBlock: { (username: String, password: String) in if username == \"hello\" && password == \"world\" { Cely.save(\"FAKETOKEN\", forKey: \"token\", securely: true) Cely.credentials.set( username: username, password: password, server: \"api.example.com\" ) Cely.changeStatus(to: .loggedIn) } } ]) } } } What's next? # Set custom LoginViewController","title":"Basic"},{"location":"usage/basic_usage/#overview","text":"","title":"Overview"},{"location":"usage/basic_usage/#introduction","text":"With the recent changes made to the App's Life Cycle , depending on what version of iOS your application will support, you will need to call Cely.setup(_:) in either your AppDelegate ( iOS 12 and earlier ) or SceneDelegate ( iOS 13 and later ). The rest of the guide will follow as if your application supports iOS 13 & later. Cely has a few defaults to help with speedy development, one of which is to include a built-in LoginViewController . If you would like to use your own, checkout setup own LoginViewController .","title":"Introduction"},{"location":"usage/basic_usage/#cely-setup","text":"Let's start by creating a User model that conforms to the CelyUser Protocol: import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } In your application's SceneDelegate.swift , paste the following: // iOS 13 | Swift 5.0 | Xcode 11.0 import Cely class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ .homeViewController: UIHostingController(rootView: HomeContentView()), .loginCompletionBlock: { (username: String, password: String) in if username == \"hello\" && password == \"world\" { // Store credentials and login print(\"Logging in...\") } } ]) } } } Now hit RUN on Xcode. You should see Cely's default login screen. Provide the credentials below and click Login . username: hello password: world","title":"Cely Setup"},{"location":"usage/basic_usage/#save-credentials","text":"Next, we need to save the credentials to Cely's secure storage using Cely.credentials . Finally, set the CelyStatus to .loggedIn to trigger your application to login. if username == \"hello\" && password == \"world\" { Cely.save(\"FAKETOKEN\", forKey: \"token\", securely: true) Cely.credentials.set( username: username, password: password, server: \"api.example.com\" ) Cely.changeStatus(to: .loggedIn) }","title":"Save Credentials"},{"location":"usage/basic_usage/#code","text":"// iOS 13 | Swift 5.0 | Xcode 11.0 import Cely struct User: CelyUser { enum Property: CelyProperty { case token = \"token\" } } class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) self.window = window window.makeKeyAndVisible() Cely.setup(with: window, forModel: User(), requiredProperties: [.token], withOptions: [ // Application entry point .homeViewController: UIHostingController(rootView: HomeContentView()), // handle Cely's default loginViewController event .loginCompletionBlock: { (username: String, password: String) in if username == \"hello\" && password == \"world\" { Cely.save(\"FAKETOKEN\", forKey: \"token\", securely: true) Cely.credentials.set( username: username, password: password, server: \"api.example.com\" ) Cely.changeStatus(to: .loggedIn) } } ]) } } }","title":"Code:"},{"location":"usage/basic_usage/#whats-next","text":"Set custom LoginViewController","title":"What's next?"}]}